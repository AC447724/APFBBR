print("Script Source Released on 17.03.2024 (DD/MM/YYYY because Islands is Dead!") warn("THIS SCRIPT IS DISCONTINUED FROM NOW!") for i = 1, 50 do print("Nekohub on Top | discord.gg/MbsxuDEzgT") end -- This is a pretty old script so dont joke abt the source type (its older than 90% of Roblox comminity) -- repeat wait() until game:IsLoaded() local IsPremium = true local DidKey = false local ScriptVersion = "V4 Final" local FileName = "cvxpk hub" local GameName = "Islands" local DeveloperVersion = true local NotificationIcon = "" function SendNotification(Title, Text) 	game:GetService("StarterGui"):SetCore("SendNotification",{ 		Title = Title, -- Required 		Text = Text, -- Required 		Icon = NotificationIcon -- Optional 	}) end	 SendNotification("Welcome!", "Welcome to "..FileName .. " " .. ScriptVersion.."!") local PremiumText1 = "Premium is only 2$ Lifetime. Go buy it in discord.gg/" if isfolder(FileName) then else 	makefolder(FileName) end if isfolder(FileName.."/"..GameName) then else 	makefolder(FileName.."/"..GameName) end function IsFile(Name) 	return isfile(FileName.."/"..GameName.."/"..Name) end	 function IsFolder(Name) 	return isfolder(FileName.."/"..GameName.."/"..Name) end	 function ReadFile(Name) 	if isfile(FileName.."/"..GameName.."/"..Name) == true then 		return readfile(FileName.."/"..GameName.."/"..Name) 	else 		return readfile(FileName.."/"..GameName..Name) 	end 	return readfile(FileName.."/"..GameName.."/"..Name) end function CreateFolder(Name) 	makefolder(FileName.."/"..GameName.."/"..Name) end	 function CreateFile(Name, Data, CheckIfFile) 	if CheckIfFile == true then 		if isfile(FileName.."/"..GameName.."/"..Name) then 		else 			writefile(FileName.."/"..GameName.."/"..Name, Data) 		end 	else 		writefile(FileName.."/"..GameName.."/"..Name, Data) 	end end	 -- local TemplateFile = game:HttpGet("https://pastebin.com/raw/yQUgfbZy") -- CreateFile("/Schematica/Template", TemplateFile, false) task.wait(1) function GetSchematicaFiles() 	local Path = FileName.."/"..GameName.."/".."Schematica" 	local Files = listfiles(Path) 	if not Files or (#Files == 0) then 		local TemplateFile = game:HttpGet("https://pastebin.com/raw/yQUgfbZy") 		CreateFile("/Schematica/Template", TemplateFile, false) 		task.wait(1) 		local Files = listfiles(Path) 		return Files; 	else 		return Files; 	end 	--[[ 	for i,v in pairs(Files) do 		print(i,v) 	end 	]] end CreateFolder("Schematica") CreateFolder("ello") -- if _G.UJGNAIKGNAJGNJSAGNLSAGLSLKRGJLKNIGANBJIERGBJISRABIGBSJIGNBSHGNNKISGABISGBSNGJSNJGSNGLJKSNG == true then if IsPremium == false then -- true 	IsPremium = true 	DidKey = true else 	DidKey = false 	-- KeySystem() end local CloneFolder if game:GetService("Workspace"):FindFirstChild("Clones/Ne_KO_HUB") then 	CloneFolder = game:GetService("Workspace"):FindFirstChild("Clones/Ne_KO_HUB") else 	local F = Instance.new("Model") 	F.Parent = game:GetService("Workspace") 	F.Name = "Clones/Ne_KO_HUB" 	CloneFolder = F end function DeleteIsland(PASSWORD) 	if PASSWORD == "UI NB)QUN BGTUI(O $ I)ONHZIO$NUI GOH)U$UB GZ)($NZOU IGHN$)(TMI)(O)" then 		game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("CLIENT_RESET_ISLAND_REQUEST"):InvokeServer() 	end end function IsInTable(Table, NameToCheck) 	if NameToCheck and Table then 		if type(Table) == "table" then 			if table.find(Table, NameToCheck) then 				return true 			else 				return false 			end 		else 			if type(Table) == "string" then 				if Table == NameToCheck then 					return true 				else 					return false 				end 			end 		end 	else 		return false 	end end function DebugCheck(N,Text) 	if _G.DebugMode == true then 		rconsolename("Debug") 		if N == nil then 			N = 0 		end 		if N == 0 then 			rconsoleprint("\n"..Text) 		end 	end end DebugCheck(0,"im waiting...") local vu = game:GetService("VirtualUser") game:GetService("Players").LocalPlayer.Idled:connect(function() 	vu:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame) 	wait(1) 	vu:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame) end) local NofLibery = loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Rayfield/main/source'))() -- https://raw.githubusercontent.com/pascaldercoole1/NekoHub-Beta/main/Nekohub%20V3 DebugCheck(0,"Loaded!") DebugCheck(0,"Anti AFK: Loaded!") game:GetService("NetworkClient"):SetOutgoingKBPSLimit(math.huge) _G.TeleportSpeed = 30 function TweenHello() 	local Notify = Instance.new("ScreenGui") 	local Background = Instance.new("Frame") 	local UICorner = Instance.new("UICorner") 	local Image = Instance.new("ImageLabel") 	local UICorner_2 = Instance.new("UICorner") 	local Label = Instance.new("TextLabel") 	local Text = Instance.new("TextLabel") 	local Line = Instance.new("Frame") 	local TweenService = game:GetService("TweenService") 	local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quint, Enum.EasingDirection.Out) 	Background.Position = UDim2.new(-1, 0, 0.5, 0) 	local tween = TweenService:Create(Background, tweenInfo, { 		Position = UDim2.new(0.05, 0, 0.5, 0) 	}) 	local function removeNotification() 		wait(3) 		tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut) 		local tweenOut = TweenService:Create(Background, tweenInfo, { 			Position = UDim2.new(-1, 0, 0.5, 0) 		}) 		tweenOut:Play() 		wait(1) 		Notify:Destroy() 	end 	Notify.Name = "Notify" 	Notify.Parent = game:GetService("CoreGui") 	Notify.ZIndexBehavior = Enum.ZIndexBehavior.Sibling 	Background.Name = "Background" 	Background.Parent = Notify 	Background.BackgroundColor3 = Color3.fromRGB(6, 5, 35) 	Background.Position = UDim2.new(0.05, 0, 0.5, 0) 	Background.Size = UDim2.new(0, 240, 0, 70) 	UICorner.CornerRadius = UDim.new(0, 15) 	UICorner.Parent = Background 	Image.Name = "Image" 	Image.Parent = Background 	Image.BackgroundColor3 = Color3.fromRGB(255, 255, 255) 	Image.BorderSizePixel = 0 	Image.Position = UDim2.new(0.0291666668, 0, 0.142857149, 0) 	Image.Size = UDim2.new(0, 50, 0, 50) 	Image.Image = "rbxassetid://12954693578" 	Image.ScaleType = Enum.ScaleType.Tile 	UICorner_2.Parent = Image 	Label.Name = "Label" 	Label.Parent = Background 	Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255) 	Label.BackgroundTransparency = 1.000 	Label.BorderSizePixel = 0 	Label.Position = UDim2.new(0.273145556, 0, 0, 0) 	Label.Size = UDim2.new(0, 167, 0, 35) 	Label.Font = Enum.Font.SourceSansBold 	Label.Text = "Neko Hub V4" 	Label.TextColor3 = Color3.fromRGB(255, 255, 255) 	Label.TextSize = 28.000 	Text.Name = "Text" 	Text.Parent = Background 	Text.BackgroundColor3 = Color3.fromRGB(255, 255, 255) 	Text.BackgroundTransparency = 1.000 	Text.BorderSizePixel = 0 	Text.Position = UDim2.new(0.273145556, 0, 0.50957489, 0) 	Text.Size = UDim2.new(0, 167, 0, 24) 	Text.Font = Enum.Font.SourceSans 	Text.Text = "Welcome!" 	Text.TextColor3 = Color3.fromRGB(255, 255, 255) 	Text.TextSize = 23.000 	Line.Name = "Line" 	Line.Parent = Background 	Line.BackgroundColor3 = Color3.fromRGB(255, 255, 255) 	Line.BackgroundTransparency = 0.300 	Line.BorderSizePixel = 0 	Line.Position = UDim2.new(0.237499997, 0, 0.5, 0) 	Line.Size = UDim2.new(0, 183, 0, 1) 	local TweenService = game:GetService("TweenService") 	local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quint, Enum.EasingDirection.Out) 	Background.Position = UDim2.new(-1, 0, 0.5, 0) 	local tween = TweenService:Create(Background, tweenInfo, { 		Position = UDim2.new(0.05, 0, 0.5, 0) 	}) 	tween:Play() 	local soundId = "rbxassetid://4695797538" 	local sound = Instance.new("Sound") 	sound.Name = "MySound" 	sound.SoundId = soundId 	sound.Volume = 1 	sound.PlaybackSpeed = 1 	sound.Looped = false 	sound.Parent = game.Workspace 	sound:Play() 	local function removeNotification() 		wait(3) 		tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quint, Enum.EasingDirection.InOut) 		local tweenOut = TweenService:Create(Background, tweenInfo, { 			Position = UDim2.new(-1, 0, 0.5, 0) 		}) 		tweenOut:Play() 		wait(1) 		Notify:Destroy() 	end 	removeNotification() end TweenHello() local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/IJHGIAJGIHJASUIJGHIUHIUHSUIAOHJAHOIBNAO/Nekohub/main/Fluent-master/main.lua"))() local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/IJHGIAJGIHJASUIJGHIUHIUHSUIAOHJAHOIBNAO/Nekohub/main/Fluent-master/Addons/SaveManager.lua"))() local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/IJHGIAJGIHJASUIJGHIUHIUHSUIAOHJAHOIBNAO/Nekohub/main/Fluent-master/Addons/InterfaceManager.lua"))() -- loadstring(game:HttpGet('https://raw.githubusercontent.com/pascaldercoole1/NekoHub-Beta/main/Nekohub%20V3'))() --[[ if _G.SVMZeGIyVb8MDqFsrL0M == true then else 	game.Players.LocalPlayer:Kick("BYE!") 	task.wait(2) 	while true do end end loadstring(game:HttpGet("https://raw.githubusercontent.com/pascaldercoole1/Islands/main/RemotesV2"))() loadstring(game:HttpGet("https://nekohub.000webhostapp.com/Islands.Remotes.Lua"))() ]] function Remotes() 	DebugCheck(0,"HASH AUTO UPDATE 4") 	function UpdateRemote(RemoteName, Value) 		if game:FindFirstChild("_REMOTES_NEKO_") == nil then 			local REMOTES = Instance.new("Folder") 			REMOTES.Name = "_REMOTES_NEKO_" 			REMOTES.Parent = game 			UpdateRemote(RemoteName, Value) 		else 			if game:FindFirstChild("_REMOTES_NEKO_"):FindFirstChild(RemoteName) == nil then 				local _NEWREMOTE = Instance.new("StringValue") 				_NEWREMOTE.Name = RemoteName 				_NEWREMOTE.Value = Value 				_NEWREMOTE.Parent = game:FindFirstChild("_REMOTES_NEKO_") 			else 				DebugCheck(0,"Remote Update: "..RemoteName) 				game:FindFirstChild("_REMOTES_NEKO_"):FindFirstChild(RemoteName).Value = Value 			end 		end 	end 	if IsFolder("/Hash System") and IsFile("Game Version") and ReadFile("Game Version") and game.PlaceVersion == tonumber(ReadFile("Game Version")) then 		print("Ist Nicht geupdated!") 		UpdateRemote("KillRemote", ReadFile("/Hash System/KillRemote")) -- 2 		UpdateRemote("KillRemoteHashName", ReadFile("/Hash System/KillRemoteHashName")) -- 2 		_G.KillRemoteHash = ReadFile("/Hash System/KillRemoteHash") 		UpdateRemote("FishFarmFinishRemote", ReadFile("/Hash System/FishFarmFinishRemote")) -- 2 		UpdateRemote("AngelRemote", ReadFile("/Hash System/AngelRemote")) -- 2 		UpdateRemote("TOOL_PICKUPHashData", ReadFile("/Hash System/TOOL_PICKUPHashData")) -- 2 		_G.TOOL_PICKUPHash = ReadFile("/Hash System/TOOL_PICKUPHash") 		UpdateRemote("CropHashData", ReadFile("/Hash System/CropHashData")) -- 2 		_G.CropHash = ReadFile("/Hash System/CropHash") 		UpdateRemote("TreeHashData", ReadFile("/Hash System/TreeHashData")) -- 2 		_G.TreeHash = ReadFile("/Hash System/TreeHash") 		UpdateRemote("BlockHitHashData", ReadFile("/Hash System/BlockHitHashData")) -- 2 		_G.BlockHitHash = ReadFile("/Hash System/BlockHitHash") 		UpdateRemote("FlowerCollect", "client_request_1") -- 1 		UpdateRemote("PetCollect", "CLIENT_PET_ANIMAL") 		UpdateRemote("BlockRemote", "CLIENT_BLOCK_HIT_REQUEST") 		UpdateRemote("SpiritRemote", "nflutpppqsFS/ZroaqkcspgrTkvpnkrdWcc") 		UpdateRemote("CropPlaceHashData", ReadFile("/Hash System/CropPlaceHashData")) -- 2 		_G.CropPlaceHash = ReadFile("/Hash System/CropPlaceHash") -- 2 		_G.CropPlaceH1 = ReadFile("/Hash System/BlockPlaceHashData") 		UpdateRemote("BlockPlaceHashData", ReadFile("/Hash System/BlockPlaceHashData")) -- 2 		_G.BlockPlaceHash = ReadFile("/Hash System/BlockPlaceHash") -- 2 	else 		CreateFolder("Hash System") 		print("Getting Hashes!") 		CreateFile("Game Version", tostring(game.PlaceVersion), false) 		function Update() 			local MOBRIGHT = "" 			local MOBLEFT = "" 			local mobRemoteName = "" 			function UpdateMob() 				local Tool 				for i,v in pairs(game:GetService("ReplicatedStorage").Tools:GetChildren()) do 					if v.Name == "swordWood" then 						local Clone = v:Clone() 						Clone.Parent = game.Players.LocalPlayer.Character 						task.wait(0.2) 						Clone.Parent = game.Players.LocalPlayer.Backpack 						task.wait(0.2) 						Clone.Parent = game.Players.LocalPlayer.Character 						task.wait(0.2) 						Tool = Clone 					end 				end 				local function getrem(p9) 					rem = "" 					for i,v in pairs(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@rbxts"].net.out["_NetManaged"]:GetChildren()) do 						if v.Name:match(p9) then 							rem = v 						end 					end 					return rem.Name 				end 				local remleft = "" 				mobrem = "" 				for i,v in pairs(getgc(true)) do 					if type(v) == "function" and getinfo(v).name == "attemptHit" then 						for i2,v2 in pairs(getprotos(v)) do 							for i3,v3 in pairs(getprotos(v2)) do 								mobrem = getrem("/"..getconstants(v3)[1]) 								remleft = getconstants(v3)[4] 							end 						end 					end 				end 				for i,v in pairs(getgc(true)) do 					if type(v) == "function" and getinfo(v).name == "attemptHit" then 						MOBRIGHT = getupvalues(v)[5] 						task.wait() -- 1 					end 				end 				print("mobrem:",mobrem) 				mobramsides = string.split(mobrem, "/") 				MOBLEFT = remleft 				if mobramsides and mobramsides[1] and mobramsides[2] then 					mobRemoteName = mobramsides[1].."/"..mobramsides[2] 					if MOBRIGHT then 						_G.KillRemoteHash = MOBRIGHT 					else 						_G.KillRemoteHash = nil 					end 				else 					_G.KillRemoteHash = nil 					local RunService = game:GetService("RunService") 					local CoreGui = game:GetService("CoreGui") 				end 				if Tool then 					DebugCheck(0,"Sword ist da") 					Tool.Parent = game.Players.LocalPlayer.Backpack 					Tool:Destroy() 				else 					DebugCheck(0,"NO SWORD!") 				end 			end 			UpdateMob() 			local Remote1 			local Remote15 			local Remote2 			function UpdateFish() 				local Tool 				for i,v in pairs(game:GetService("ReplicatedStorage").Tools:GetChildren()) do 					if v.Name == "fishingRod" then 						local Clone = v:Clone() 						Clone.Parent = game.Players.LocalPlayer.Character 						task.wait(0.5) 						Clone.Parent = game.Players.LocalPlayer.Backpack 						task.wait(0.5) 						Clone.Parent = game.Players.LocalPlayer.Character 						task.wait(0.5) 						Tool = Clone 					end 				end 				local function getrem(p9) 					rem = "" 					for i,v in pairs(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@rbxts"].net.out["_NetManaged"]:GetChildren()) do 						if v.Name:match(p9) then 							rem = v 						end 					end 					return rem.Name 				end 				local WerfRemote 				local dump1 				local dump2 				if Tool then 					local ToolScript = Tool:FindFirstChild("fishing-rod") 					if Tool and ToolScript then 						for i,v222 in pairs(getgc(true)) do 							if type(v222) == "function" and getfenv(v222).script == ToolScript then 								for i,v in pairs(getconstants(v222)) do 									if i == 9 then 										if getrem(v) then 											DebugCheck(0,v) 											if v == 1.5 or v == "1.5" then 											else 												Remote1 = v 												Remote15 = string.split(Remote1, "/")[1] 												DebugCheck(0,"Remote15:",Remote15) 											end 										end 									end 									if i == 3 then 										if type(v) == "string" then 											if getrem(v) then 												Remote2 = v 												dump2 = Remote2 											end 										end 									end 								end 							end 						end 						local FinishRemote 						local function getrem(p9) 							rem = "" 							for i,v in pairs(game:GetService("ReplicatedStorage")["rbxts_include"]["node_modules"]["@rbxts"].net.out["_NetManaged"]:GetChildren()) do 								if v.Name:match(p9) then 									rem = v 								end 							end 							return rem.Name 						end 						for i,v222 in pairs(getgc(true)) do 							if type(v222) == "function" and getinfo(v222).name == "handleGameOver" and getfenv(v222).script == game:GetService("Players").LocalPlayer.PlayerScripts.TS.flame.controllers.fishing["fishing-controller"] then 								for i,v in pairs(getconstants(v222)) do 									if type(v) == "string" then 										if getrem(v) then 											if i == 2 then 												DebugCheck(0,"FINISH: ",v) 												dump1 = v 												DebugCheck(0,Remote15) 												WerfRemote = Remote2.."/"..Remote15 												DebugCheck(0,"FNISH2:",WerfRemote) 											end 										end 									end 								end 							end 						end 						--[[ 								if FinishRemote then 									UpdateRemote("FishFarmFinishRemote", FinishRemote) 									DebugCheck(0,"FishFarmFinishRemote", FinishRemote) 								else 									game.Players.LocalPlayer:Kick("cant get FinishRemote!") 								end 								if FinishRemote then 									UpdateRemote("AngelRemote", Remote1) 									DebugCheck(0,"AngelRemote", Remote1) 								else 									game.Players.LocalPlayer:Kick("cant get AngelRemote!") 								end 						]] 					end 				end 				local Finishremote = dump2.."/"..dump1 				DebugCheck(0,"FinishRemote:",Finishremote) 				if WerfRemote then 					DebugCheck(0,"WerfRemote:",WerfRemote) 				end 				UpdateRemote("FishFarmFinishRemote", Finishremote) -- 2 				SendNotification("[SECURITY]", "Check 1/42 Done!") 				UpdateRemote("AngelRemote", WerfRemote) -- 2 				SendNotification("[SECURITY]", "Check 2/42 Done!") 				CreateFile("/Hash System/FishFarmFinishRemote", Finishremote, false) 				SendNotification("[SECURITY]", "Check 3/42 Done!") 				CreateFile("/Hash System/AngelRemote", WerfRemote, false) 				SendNotification("[SECURITY]", "Check 4/42 Done!") 				Tool.Parent = game.Players.LocalPlayer.Backpack 				Tool:Destroy() 			end 			-- UpdateFish() 			task.spawn(function() 				UpdateFish() 				task.wait() 			end) 			function Updateinv(v) 				if v:FindFirstChild("sword") then 					if _G.KillRemoteHash == nil or _G.KillRemoteHash == "" or _G.KillRemoteHash == " " then 						UpdateMob() 						task.wait() 						UpdateRemote("KillRemote", mobRemoteName) -- 2 						SendNotification("[SECURITY]", "Check 5/42 Done!") 						UpdateRemote("KillRemoteHashName", MOBLEFT) -- 2 						SendNotification("[SECURITY]", "Check 6/42 Done!") 						_G.KillRemoteHash = MOBRIGHT 						SendNotification("[SECURITY]", "Check 7/42 Done!") 					end 				end 			end 			game.Players.LocalPlayer.Backpack.ChildAdded:Connect(function(v) 				Updateinv(v) 			end) 			game.Players.LocalPlayer.Backpack.ChildRemoved:Connect(function(v) 				Updateinv(v) 			end) 			print("mobRemoteName:",mobRemoteName) 			UpdateRemote("KillRemote", mobRemoteName) -- 2 			SendNotification("[SECURITY]", "Check 8/42 Done!") 			UpdateRemote("KillRemoteHashName", MOBLEFT) -- 2 			SendNotification("[SECURITY]", "Check 9/42 Done!") 			_G.KillRemoteHash = MOBRIGHT 			print("Debug 1") 			task.wait() 			CreateFile("/Hash System/KillRemote", mobRemoteName, false) 			SendNotification("[SECURITY]", "Check 10/42 Done!") 			CreateFile("/Hash System/KillRemoteHashName", MOBLEFT, false) 			SendNotification("[SECURITY]", "Check 11/42 Done!") 			CreateFile("/Hash System/KillRemoteHash", MOBRIGHT or _G.KillRemoteHash, false) 			SendNotification("[SECURITY]", "Check 12/42 Done!") 			print("Debug 2") 			local ToolLEFT 			local TOOLRIGHT 			function UpdatePickUpTool() 				for i,v in pairs(getgc(true)) do 					if type(v) == "function" and getinfo(v).name == "pickupTool" then 						ToolLEFT = getconstants(v)[23] 						TOOLRIGHT = getconstants(v)[25]..getconstants(v)[26] 					end 				end 			end 			task.spawn(function() 				UpdatePickUpTool() 			end) 			print("Debug 3") 			UpdateRemote("TOOL_PICKUPHashData", ToolLEFT) -- 2 			SendNotification("[SECURITY]", "Check 13/42 Done!") 			_G.TOOL_PICKUPHash = TOOLRIGHT 			SendNotification("[SECURITY]", "Check 14/42 Done!") 			CreateFile("/Hash System/TOOL_PICKUPHashData", ToolLEFT, false) 			SendNotification("[SECURITY]", "Check 15/42 Done!") 			CreateFile("/Hash System/TOOL_PICKUPHash", TOOLRIGHT, false) 			SendNotification("[SECURITY]", "Check 16/42 Done!") 			print("Debug 4") 			local CROPleft 			local CROPright 			function CropUpdate() 				remleft = "" 				remright = "" 				for i,v in pairs(getgc(true)) do 					if type(v) == "function" and getinfo(v).name == "breakCrop" and getfenv(v).script == game.Players.LocalPlayer.PlayerScripts.TS.block.crop["crop-service"] then 						for i2,v2 in pairs(getprotos(v)) do 							for i,v in pairs(getconstants(v)) do 								if i == 22 then 									remleft = v 								end 								if i == 26 then 									remright = v 								end 								if i == 27 then 									remright = remright..v 								end 							end 						end 					end 				end 				if remleft and remright then 					CROPleft = remleft 					CROPright = remright 				else 					game.Players.LocalPlayer:Kick("Error: NCD1") 				end 			end 			task.spawn(function() 				CropUpdate() 			end) 			print("Debug 5") 			local HITleft 			local HITright 			function HitUpdate() 				remright2 = "" 				remleft = "" 				remright = "" 				for i,v in pairs(getgc(true)) do 					if type(v) == "function" and getinfo(v).name == "onBlockHit" then 						for i2,v2 in pairs(getprotos(v)) do 							if table.find(getconstants(v2), "Get") then 								for i3,v3 in pairs(getconstants(v2)) do 									remleft = getconstants(v2)[8] 									remright2 = getconstants(v2)[11] 									remright = getconstants(v2)[10] 								end 							end 						end 					end 				end 				HITleft = remleft 				HITright = remright..remright2 			end 			task.spawn(function() 				HitUpdate() 			end) 			task.wait(0.2) 			print("Debug 6") 			UpdateRemote("CropHashData", CROPleft) -- 2 			SendNotification("[SECURITY]", "Check 17/42 Done!") 			_G.CropHash = CROPright 			SendNotification("[SECURITY]", "Check 18/42 Done!") 			UpdateRemote("TreeHashData", HITleft) -- 2 			SendNotification("[SECURITY]", "Check 19/42 Done!") 			_G.TreeHash = HITright 			SendNotification("[SECURITY]", "Check 20/42 Done!") 			UpdateRemote("BlockHitHashData", HITleft) -- 2 			SendNotification("[SECURITY]", "Check 21/42 Done!") 			_G.BlockHitHash = HITright 			SendNotification("[SECURITY]", "Check 22/42 Done!") 			CreateFile("/Hash System/CropHashData", CROPleft, false) 			SendNotification("[SECURITY]", "Check 23/42 Done!") 			CreateFile("/Hash System/CropHash", CROPright, false) 			SendNotification("[SECURITY]", "Check 24/42 Done!") 			print("Debug 7") 			CreateFile("/Hash System/TreeHashData", HITleft, false) 			SendNotification("[SECURITY]", "Check 25/42 Done!") 			CreateFile("/Hash System/TreeHash", HITright, false) 			SendNotification("[SECURITY]", "Check 26/42 Done!") 			CreateFile("/Hash System/BlockHitHashData", HITleft, false) 			SendNotification("[SECURITY]", "Check 27/42 Done!") 			CreateFile("/Hash System/BlockHitHash", HITright, false) 			SendNotification("[SECURITY]", "Check 28/42 Done!") 			print("Debug 8") 			local BlockRight1 			local BlockRight 			local BlockLeft 			function UpdatePlaceBlocks() 				for i,v in pairs(getgc(true)) do 					if type(v) == "function" and getfenv(v).script == game.Players.LocalPlayer.PlayerScripts.TS.flame.controllers.block["block-controller"] then 						for dddi,dddv in pairs(getconstants(v)) do 							print("hi",dddi, "Real", dddv) 							if tonumber(dddi) == 23 then 								print("FOUND LEFT HASH!", dddv) 								BlockLeft = dddv 							end 							if tonumber(dddi) == 25 then 								print("FOUND 1!", dddv) 								BlockLeft1 = dddv 							end 							if tonumber(dddi) == 26 then 								print("FOUND 2!", dddv) 								BlockRight = BlockLeft1..dddv 							end 						end 						if table.find(getconstants(v), "Get") then 							print("Hi, found!!!") 							for i2,v2 in pairs(getconstants(v)) do 								BlockLeft = "lFjp" -- tostring(getconstants(v)[23]) 								print("HIII") 								BlockRight = utf8.char(7, 129315, 129313, 7, 10, 7, 10, 7, 10, 112, 104, 119, 102, 106, 115, 120, 106, 116, 102, 101, 102, 109, 108, 98, 110) --getconstants(v)[25]..getconstants(v)[26] 							end 						end 					end 				end 			end 			UpdatePlaceBlocks() 			print("Debug 9") 			function GetNet() 				local A1 				local A2 				for i,v in pairs(getgc(true)) do 					if type(v) == "function" and getinfo(v).name == "constructor" and getfenv(v).script == game:GetService("Workspace").ANTICATBYASHO.net.net then 						for i2,v2 in pairs(getprotos(v)) do 							A1 = getconstants(v2)[16] 							A2 = getconstants(v2)[13] 							for i,v in pairs(getconstants(v2)) do 								DebugCheck(0,i,v, " | type:", type(v)) 							end 						end 					end 				end 				DebugCheck(0,A1) 				DebugCheck(0,A2) 			end 			print("Debug 10") 			UpdateRemote("FlowerCollect", "client_request_1") -- 1 			SendNotification("[SECURITY]", "Check 29/42 Done!") 			UpdateRemote("PetCollect", "CLIENT_PET_ANIMAL") 			SendNotification("[SECURITY]", "Check 30/42 Done!") 			UpdateRemote("BlockRemote", "CLIENT_BLOCK_HIT_REQUEST") 			SendNotification("[SECURITY]", "Check 31/42 Done!") 			-- UpdateRemote("SendMailRemote", "NINGI(HUINUH(UIN(IH(HUUI") 			SendNotification("[SECURITY]", "Check 32/42 Done!") 			UpdateRemote("SpiritRemote", "gecqaLhbvAbyjo/qDgqEvuQzyryuBnlzh") 			SendNotification("[SECURITY]", "Check 33/42 Done!") 			print("BlockLeft:",BlockLeft) 			UpdateRemote("CropPlaceHashData", BlockLeft) -- 2 			SendNotification("[SECURITY]", "Check 34/42 Done!") 			_G.CropPlaceHash = BlockRight -- 2 			SendNotification("[SECURITY]", "Check 35/42 Done!") 			_G.CropPlaceH1 = BlockLeft 			SendNotification("[SECURITY]", "Check 36/42 Done!") 			UpdateRemote("BlockPlaceHashData", BlockLeft) -- 2 			SendNotification("[SECURITY]", "Check 37/42 Done!") 			_G.BlockPlaceHash = BlockRight -- 2 			SendNotification("[SECURITY]", "Check 38/42 Done!") 			print("Debug 11") 			CreateFile("/Hash System/CropPlaceHashData", BlockLeft, false) 			SendNotification("[SECURITY]", "Check 39/42 Done!") 			CreateFile("/Hash System/CropPlaceHash", BlockRight, false) 			SendNotification("[SECURITY]", "Check 40/42 Done!") 			CreateFile("/Hash System/BlockPlaceHashData", BlockLeft, false) 			SendNotification("[SECURITY]", "Check 41/42 Done!") 			CreateFile("/Hash System/BlockPlaceHash", BlockRight, false) 			SendNotification("[SECURITY]", "Check 42/42 Done!") 		end 		Update() 	end end SendNotification("[SECURITY]", "Scanning Game...") Remotes() function FixInv() 	for i,v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do 		v.Parent = game.Players.LocalPlayer.Character 		task.wait() 		v.Parent = game.Players.LocalPlayer.Backpack 		task.wait() 	end end local RemoteData = game:WaitForChild("_REMOTES_NEKO_") _G.Island_USERID = game.Players.LocalPlayer.UserId local CANUSEAUTOCLICKER = true local MotHitH1 = RemoteData:FindFirstChild("KillRemoteHashName").Value local MotHitH2 = _G.KillRemoteHash local CropPlaceH1 = RemoteData:FindFirstChild("CropPlaceHashData").Value local CropPlaceH2 = _G.CropPlaceHash local PickupH1 = RemoteData:FindFirstChild("TOOL_PICKUPHashData").Value local PickupH2 = _G.TOOL_PICKUPHash local PlaceHASHName = RemoteData:FindFirstChild("BlockPlaceHashData").Value local PlaceHASH = _G.BlockPlaceHash local HitHASHName = RemoteData:FindFirstChild("BlockHitHashData").Value local HitHASH = _G.BlockHitHash local MAINSCRIPTHANDLER local LASTTWEEN = nil -- CROP TEST -- local SichleAuraCooldown = false local SichleFarmCooldown = false local CROPTWEEN22 -- Tables -- local SettingsTable = { 	-- Tween Fly -- 	Twennnoclip = true, 	TweenFly = true, 	TweenFast = true, 	-- Player -- 	PlayerFly = false, 	-- Script -- 	AutoUpdate = true } local UserSettings = { 	TeleportMethod = "Tween" -- or Instant } local MaxCropDis = 30 local FloatRender local FloatPart local UseFloat = false local Float_Part = Instance.new('Part') Float_Part.Name = "floatName" Float_Part.Parent = game.Players.LocalPlayer.Character Float_Part.Transparency = 1 Float_Part.Size = Vector3.new(2,0.2,1.5) Float_Part.Anchored = true FloatPart = Float_Part FloatRender = game:GetService("RunService").RenderStepped:Connect(function() 	if UseFloat == true then 		Float_Part.CanCollide = true 		Float_Part.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,-3.1,0) 	else 		Float_Part.CanCollide = false 	end end) function MiniTpBlocks(Model,position) 	if Model then 		for i,v in pairs(Model:GetDescendants()) do 			if v:IsA("Part") or v:IsA("BasePart") then 				v.CanCollide = false 			end 		end 	end 	local function MiniTpV2(position) 		Model:SetPrimaryPartCFrame(CFrame.new(position)) 	end 	local myPart = Model.PrimaryPart 	local targetPosition = position 	local minDistance = 3 -- Minimum distance to target to trigger teleport 	local maxIterations = 3 -- Maximum number of iterations to allow with no progress 	DebugCheck(0,"Initial Position: " .. tostring(myPart.Position)) 	DebugCheck(0,"Target Position: " .. tostring(targetPosition)) 	local prevDistance = (myPart.Position - targetPosition).magnitude 	local noProgressCount = 0 	while (myPart.Position - targetPosition).magnitude > minDistance do 		local offset = targetPosition - myPart.Position 		local distance = offset.Magnitude 		local step 		local waitTime 		step = Vector3.new(3, 3, 3) 		waitTime = 0 		local direction = offset.Unit 		local steps = math.ceil(distance / step.Magnitude) 		local newStep = offset / steps 		local progress = false 		for i = 1, steps do 			local newPos = myPart.Position + newStep * i 			if newPos.X > targetPosition.X and newStep.X > 0 then 				newStep = Vector3.new(0, newStep.Y, newStep.Z) 			elseif newPos.X < targetPosition.X and newStep.X < 0 then 				newStep = Vector3.new(0, newStep.Y, newStep.Z) 			end 			if newPos.Y > targetPosition.Y and newStep.Y > 0 then 				newStep = Vector3.new(newStep.X, 0, newStep.Z) 			elseif newPos.Y < targetPosition.Y and newStep.Y < 0 then 				newStep = Vector3.new(newStep.X, 0, newStep.Z) 			end 			if newPos.Z > targetPosition.Z and newStep.Z > 0 then 				newStep = Vector3.new(newStep.X, newStep.Y, 0) 			elseif newPos.Z < targetPosition.Z and newStep.Z < 0 then 				newStep = Vector3.new(newStep.X, newStep.Y, 0) 			end 			newPos = myPart.Position + newStep 			MiniTpV2(newPos) 			DebugCheck(0,"Current Position: " .. tostring(myPart.Position)) 			DebugCheck(0,"In radius!") -- Ausgabe, wenn der Spieler innerhalb des Radius ist 			wait(waitTime) 			local currDistance = (myPart.Position - targetPosition).magnitude 			if currDistance >= prevDistance then 				noProgressCount = noProgressCount + 1 			else 				prevDistance = currDistance 				noProgressCount = 0 				progress = true 			end 			if noProgressCount >= maxIterations then 				DebugCheck(0,"Stuck! Breaking out of loop...") 				break 			end 		end 		if not progress then 			DebugCheck(0,"Stuck! Breaking out of loop...") 			break 		end 	end 	--[[ 		-- Teleport to target position if close enough 	if (myPart.Position - targetPosition).magnitude <= minDistance then 		MiniTpV2(targetPosition) 	end 	DebugCheck(0,"Final Position: " .. tostring(myPart.Position)) 	DebugCheck(0,"Reached Target Position!") 	FloatRender:Disconnect() 	FloatPart:Destroy() 	]] end function MiniTp(position) 	UseFloat = true 	local function MiniTpV2(position) 		local player = game:GetService("Players").LocalPlayer 		local character = player.Character 		if character and character.PrimaryPart then 			character:SetPrimaryPartCFrame(CFrame.new(position)) 		end 	end 	local myPart = game.Players.LocalPlayer.Character.HumanoidRootPart 	local targetPosition = position 	local minDistance = 3 -- Minimum distance to target to trigger teleport 	local maxIterations = 3 -- Maximum number of iterations to allow with no progress 	DebugCheck(0,"Initial Position: " .. tostring(myPart.Position)) 	DebugCheck(0,"Target Position: " .. tostring(targetPosition)) 	local prevDistance = (myPart.Position - targetPosition).magnitude 	local noProgressCount = 0 	while (myPart.Position - targetPosition).magnitude > minDistance do 		local offset = targetPosition - myPart.Position 		local distance = offset.Magnitude 		local step 		local waitTime 		if distance <= 50 then 			step = Vector3.new(1, 2, 1) 			waitTime = 0.04 		elseif distance <= 30 then 			step = Vector3.new(1, 2, 1) 			waitTime = 0.005 		else 			step = Vector3.new(2.5, 4.5, 2.5) 			waitTime = 0.20 		end 		local direction = offset.Unit 		local steps = math.ceil(distance / step.Magnitude) 		local newStep = offset / steps 		local progress = false 		for i = 1, steps do 			local newPos = myPart.Position + newStep * i 			if newPos.X > targetPosition.X and newStep.X > 0 then 				newStep = Vector3.new(0, newStep.Y, newStep.Z) 			elseif newPos.X < targetPosition.X and newStep.X < 0 then 				newStep = Vector3.new(0, newStep.Y, newStep.Z) 			end 			if newPos.Y > targetPosition.Y and newStep.Y > 0 then 				newStep = Vector3.new(newStep.X, 0, newStep.Z) 			elseif newPos.Y < targetPosition.Y and newStep.Y < 0 then 				newStep = Vector3.new(newStep.X, 0, newStep.Z) 			end 			if newPos.Z > targetPosition.Z and newStep.Z > 0 then 				newStep = Vector3.new(newStep.X, newStep.Y, 0) 			elseif newPos.Z < targetPosition.Z and newStep.Z < 0 then 				newStep = Vector3.new(newStep.X, newStep.Y, 0) 			end 			newPos = myPart.Position + newStep 			MiniTpV2(newPos) 			DebugCheck(0,"Current Position: " .. tostring(myPart.Position)) 			DebugCheck(0,"In radius!") -- Ausgabe, wenn der Spieler innerhalb des Radius ist 			wait(waitTime) 			local currDistance = (myPart.Position - targetPosition).magnitude 			if currDistance >= prevDistance then 				noProgressCount = noProgressCount + 1 			else 				prevDistance = currDistance 				noProgressCount = 0 				progress = true 			end 			if noProgressCount >= maxIterations then 				DebugCheck(0,"Stuck! Breaking out of loop...") 				break 			end 		end 		if not progress then 			DebugCheck(0,"Stuck! Breaking out of loop...") 			break 		end 	end 	-- Teleport to target position if close enough 	if (myPart.Position - targetPosition).magnitude <= minDistance then 		MiniTpV2(targetPosition) 	end 	DebugCheck(0,"Final Position: " .. tostring(myPart.Position)) 	DebugCheck(0,"Reached Target Position!") 	UseFloat = false end local function erstellePart(position) 	local part = Instance.new("Part") 	part.Position = position 	part.Anchored = true 	part.Size = Vector3.new(1, 1, 1) 	part.BrickColor = BrickColor.new("Bright red") 	part.Parent = game.Workspace 	part.CanCollide = false 	part.Transparency = 0.65 	task.spawn(function() 		task.wait(10) 		part:Destroy() 	end) end local function followPathV2(destination) 	local PathfindingService = game:GetService("PathfindingService") 	local Players = game:GetService("Players") 	local RunService = game:GetService("RunService") 	local player = Players.LocalPlayer 	local character = player.Character 	local humanoid = character:WaitForChild("Humanoid") 	local HumanoidRootPart = character:WaitForChild("HumanoidRootPart") 	local path = PathfindingService:CreatePath() 	local GoodAndFinished = false 	-- Compute the path 	local success, errorMessage = pcall(function() 		path:ComputeAsync(character.PrimaryPart.Position, destination) 	end) 	if success and path.Status == Enum.PathStatus.Success then 		-- Get the path waypoints 		waypoints = path:GetWaypoints() 		-- Detect if path becomes blocked 		blockedConnection = path.Blocked:Connect(function(blockedWaypointIndex) 			-- Check if the obstacle is further down the path 			if blockedWaypointIndex >= nextWaypointIndex then 				-- Stop detecting path blockage until path is re-computed 				blockedConnection:Disconnect() 				-- Call function to re-compute new path 				followPath(destination) 			end 		end) 		-- Detect when movement to next waypoint is complete 		if not reachedConnection then 			reachedConnection = humanoid.MoveToFinished:Connect(function(reached) 				if reached and nextWaypointIndex < #waypoints then 					-- Increase waypoint index and move to next waypoint 					nextWaypointIndex = nextWaypointIndex + 1 					humanoid:MoveTo(waypoints[nextWaypointIndex].Position) 				else 					reachedConnection:Disconnect() 					blockedConnection:Disconnect() 				end 			end) 		end 		-- Initially move to second waypoint (first waypoint is path start; skip it) 		if GoodAndFinished == true then return nil end 		nextWaypointIndex = 2 		for i = 1,#waypoints do 			erstellePart(waypoints[i].Position + Vector3.new(0,2,0)) 		end 		for i = 1,#waypoints do 			HumanoidRootPart.CFrame = CFrame.new(waypoints[i].Position + Vector3.new(0,2,0)) 			task.wait(0.2) -- 0.1 		end 		task.wait(2) 		GoodAndFinished = true 		return true 	else 		warn("Path not computed!", errorMessage) 		local tpservice= game:GetService("TeleportService") 		local plr = game.Players.LocalPlayer 		task.wait(1) 		--tpservice:Teleport(game.PlaceId, plr) 		return errorMessage 	end end local TeleportV4Wait = false function TeleportV4(Position) 	local ISARENDER = nil 	--[[ 	if LASTTWEEN == nil then 		warn("Tween ist nil!") 	else 		LASTTWEEN:Cancel() 	end 	]] 	if Position ~= nil then 		--[[ 	if typeof(Position)=="Vector3" then 		local dist=(game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position-Position).Magnitude 		if dist < 3 then 			game.Players.LocalPlayer.Character:MoveTo(Position) 			task.wait() 			return nil 		end 	end 		]] 		if _G.TeleportMethod == "Tween" then 			TweenTp(Position) 			task.wait() 			return true 		elseif _G.TeleportMethod == "TweenV2" then	 			if typeof(Position)=="Vector3" then 				if Position.Y then 					local HUM = game.Players.LocalPlayer.Character.HumanoidRootPart 					game.Players.LocalPlayer.Character:MoveTo(Vector3.new(HUM.Position.X, Position.Y, HUM.Position.Z)) 				end 			end 			local dist=(game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position-Position).Magnitude 			tweenService, tweenInfo = game:GetService("TweenService"), TweenInfo.new(dist/30, Enum.EasingStyle.Linear) 			local ALRE = true 			tween = tweenService:Create(game:GetService("Players")["LocalPlayer"].Character.HumanoidRootPart, tweenInfo, {CFrame = CFrame.new(Position)}) 			CROPTWEEN22 = tween 			LASTTWEEN = tween 			tween:Play() 			task.wait() 			return true 		elseif _G.TeleportMethod == "TweenV3" then	 			local PartToMove = game.Players.LocalPlayer.Character.HumanoidRootPart 			local TargetPos = CFrame.new(Position) 			local Dis = (PartToMove.Position - Vector3.new(TargetPos.X, TargetPos.Y, TargetPos.Z)).Magnitude 			local _speed = 15 			local Completed = false 			if Dis < 30 then 				_speed = 15 			end 			if Dis < 10 then 				_speed = 20 			end 			_speed = _speed 			local TimeToRun = TweenInfo.new(Dis/_speed) 			local WhatToChange = { 				CFrame = TargetPos 			} -- sets CFrame to localplayers position + 30 on the Y axis (brings you upwards) 			-- to limit the player and to not allow them to move, you can uncomment anchored below 			function Noclip(V) 				if V == true then 					V = false 				else 					V = true 				end 				for _, child in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do 					if child:IsA("BasePart") and child.CanCollide == true then 						child.CanCollide = V 					end 				end 			end 			function DoAfter() 				PartToMove.Anchored = false 				Noclip(false) 				Completed = true 			end 			local tween = game:GetService("TweenService"):Create(PartToMove, TimeToRun, WhatToChange) 			CROPTWEEN22 = tween 			LASTTWEEN = tween 			Noclip(true) 			task.spawn(function() 				repeat 					task.wait() 					game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(PartToMove.Position.X, TargetPos.Y, PartToMove.Position.Z)) 				until Completed == true 			end) 			tween:Play() 			tween.Completed:Connect(DoAfter) 		elseif _G.TeleportMethod == "Instant" then 			UseFloat = true 			game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(Position) 			FloatRender:Disconnect() 			FloatPart:Destroy() 			task.spawn(function() 				task.wait(0.2) 				UseFloat = false 			end) 			return true 		elseif _G.TeleportMethod == "MiniTp" then 			if TeleportV4Wait == false then 				TeleportV4Wait = true 				MiniTp(Position) 				task.wait() 				TeleportV4Wait = false 				FloatRender:Disconnect() 				FloatPart:Destroy() 				task.wait() 				return true 			end 		elseif _G.TeleportMethod == "Pathfinding" then 			local PART = Instance.new("Part") 			PART.CFrame = CFrame.new(Position) 			PART.Anchored = true 			PART.Transparency = 1 			PathFindingSystem(PART) 			return true 		elseif _G.TeleportMethod == "PathfindingV2" then 			followPathV2(Position) 			return true 		elseif _G.TeleportMethod == "Bypass" then 			ISARENDER = game:GetService("RunService").RenderStepped:Connect(function() 				for i = 1,5 do 					wait(0.1) 					task.spawn(function() 						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(Position) 					end) 				end 			end) 		end 	else 		warn("Position ist nil!") 	end 	if ISARENDER then 		task.wait(5) 		ISARENDER:Disconnect() 	end end -- Tables -- local currentDate = os.date("*t") local month = currentDate.month local day = currentDate.day local holidayMessage = "" if month == 12 and day == 25 then 	holidayMessage = "🎄" elseif month == 10 and day == 31 then 	holidayMessage = "🎃" elseif month == 12 and day == 31 then 	holidayMessage = "🎆" else 	holidayMessage = "" end local Window local Tabs if DeveloperVersion == false then 	if DidKey == true then 		Window = Fluent:CreateWindow({ 			Title = "Islands.God "..ScriptVersion.." [FREE!] "..holidayMessage, 			SubTitle = "by swiftey343 and Sealanterns12", -- neverloseyoursmile_88 			TabWidth = 160, 			Size = UDim2.fromOffset(580, 460), 			Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely 			Theme = "Dark", 			MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind 		}) 		Tabs = { 			Main = Window:AddTab({ Title = "Main", Icon = "sword" }), 			Teleports = Window:AddTab({ Title = "Teleports", Icon = "bus" }), 			BlockPrinter = Window:AddTab({ Title = "Block Printer", Icon = "printer" }), 			Player = Window:AddTab({ Title = "Player", Icon = "PlayerIcon" }), 			VendingSniper = Window:AddTab({ Title = "Vending Sniper", Icon = "file-search" }), 			BypassFun = Window:AddTab({ Title = "Bypass.Fun", Icon = "server" }), 			Other = Window:AddTab({ Title = "Other", Icon = "sidebar" }), 			Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }), 			Premium = Window:AddTab({ Title = "Premium", Icon = "star" }) 		} 	else 		Window = Fluent:CreateWindow({ 			Title = "Islands.God "..ScriptVersion.." [Premium!] "..holidayMessage, 			SubTitle = "by swiftey343 and soldo_io", -- neverloseyoursmile_88 			TabWidth = 160, 			Size = UDim2.fromOffset(580, 460), 			Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely 			Theme = "Dark", 			MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind 		}) 		Tabs = { 			Main = Window:AddTab({ Title = "Main", Icon = "sword" }), 			Teleports = Window:AddTab({ Title = "Teleports", Icon = "bus" }), 			BlockPrinter = Window:AddTab({ Title = "Block Printer", Icon = "printer" }), 			Player = Window:AddTab({ Title = "Player", Icon = "PlayerIcon" }), 			VendingSniper = Window:AddTab({ Title = "Vending Sniper", Icon = "file-search" }), 			BypassFun = Window:AddTab({ Title = "Bypass.Fun", Icon = "server" }), 			Other = Window:AddTab({ Title = "Other", Icon = "sidebar" }), 			Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }), 		} 	end else 	Window = Fluent:CreateWindow({ 		Title = "Islands.God "..ScriptVersion.." [Developer!] "..holidayMessage, 		SubTitle = "by swiftey343 and soldo_io", -- neverloseyoursmile_88 		TabWidth = 160, 		Size = UDim2.fromOffset(580, 460), 		Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely 		Theme = "Dark", 		MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind 	}) 	Tabs = { 		Main = Window:AddTab({ Title = "Main", Icon = "sword" }), 		Teleports = Window:AddTab({ Title = "Teleports", Icon = "bus" }), 		BlockPrinter = Window:AddTab({ Title = "Block Printer", Icon = "printer" }), 		Player = Window:AddTab({ Title = "Player", Icon = "PlayerIcon" }), 		VendingSniper = Window:AddTab({ Title = "Vending Sniper", Icon = "file-search" }), 		BypassFun = Window:AddTab({ Title = "Bypass.Fun", Icon = "server" }), 		Other = Window:AddTab({ Title = "Other", Icon = "sidebar" }), 		Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }), 		DeveloperTab = Window:AddTab({ Title = "Dev", Icon = "" }), 	} end local Options = Fluent.Options if DidKey == true then 	local H = Tabs.Premium:AddParagraph({ 		Title = "Why Premium?", 		Content = "with Premium you Get Faster&Beta Updates!" 	}) 	local H = Tabs.Premium:AddParagraph({ 		Title = "How to buy?", 		Content = "Join discord.gg/MbsxuDEzgT and open a ticket." 	}) 	local H = Tabs.Premium:AddParagraph({ 		Title = "What Payment Methods?", 		Content = "You can buy the Script with:\n1.Paypal\n2.Robux" 	}) 	local H = Tabs.Premium:AddParagraph({ 		Title = "How much does it cost?", 		Content = "1.Paypal: 2$\n2.Robux:800R$" 	}) 	local H = Tabs.Premium:AddParagraph({ 		Title = "Why do you wait?", 		Content = "Go buy Premium!" 	}) 	Tabs.Premium:AddButton({ 		Title = "Copy Server Invite", 		Description = "", 		Callback = function() 			setclipboard("discord.gg/MbsxuDEzgT") 		end 	}) end -- // functions \\ -- IYMouse = game.Players.LocalPlayer:GetMouse() Players = game.Players iyflyspeed = 1 function NOFLY() 	FLYING = false 	if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end 	if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then 		Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false 	end 	pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end) end function sFLY(vfly) 	repeat wait() until IYMouse 	if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end 	T = Players.LocalPlayer.Character.HumanoidRootPart 	CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0} 	lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0} 	SPEED = 0 	local function FLY() 		FLYING = true 		local BG = Instance.new('BodyGyro') 		local BV = Instance.new('BodyVelocity') 		BG.P = 9e4 		BG.Parent = T 		BV.Parent = T 		BG.maxTorque = Vector3.new(9e9, 9e9, 9e9) 		BG.cframe = T.CFrame 		BV.velocity = Vector3.new(0, 0, 0) 		BV.maxForce = Vector3.new(9e9, 9e9, 9e9) 		task.spawn(function() 			repeat wait() 				if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then 					Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true 				end 				if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then 					SPEED = 50 				elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then 					SPEED = 0 				end 				if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then 					BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED 					lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R} 				elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then 					BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED 				else 					BV.velocity = Vector3.new(0, 0, 0) 				end 				BG.cframe = workspace.CurrentCamera.CoordinateFrame 			until not FLYING 			CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0} 			lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0} 			SPEED = 0 			BG:Destroy() 			BV:Destroy() 			if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then 				Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false 			end 		end) 	end 	flyKeyDown = IYMouse.KeyDown:Connect(function(KEY) 		if KEY:lower() == 'w' then 			CONTROL.F = (iyflyspeed) 		elseif KEY:lower() == 's' then 			CONTROL.B = - (iyflyspeed) 		elseif KEY:lower() == 'a' then 			CONTROL.L = - (iyflyspeed) 		elseif KEY:lower() == 'd' then 			CONTROL.R = (iyflyspeed) 		elseif QEfly and KEY:lower() == 'e' then 			CONTROL.Q = iyflyspeed*2 		elseif QEfly and KEY:lower() == 'q' then 			CONTROL.E = -iyflyspeed*2 		end 		pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end) 	end) 	flyKeyUp = IYMouse.KeyUp:Connect(function(KEY) 		if KEY:lower() == 'w' then 			CONTROL.F = 0 		elseif KEY:lower() == 's' then 			CONTROL.B = 0 		elseif KEY:lower() == 'a' then 			CONTROL.L = 0 		elseif KEY:lower() == 'd' then 			CONTROL.R = 0 		elseif KEY:lower() == 'e' then 			CONTROL.Q = 0 		elseif KEY:lower() == 'q' then 			CONTROL.E = 0 		end 	end) 	FLY() end function Hash() 	local HttpService = game:GetService("HttpService") 	local Abd = HttpService:GenerateGUID(false)..HttpService:GenerateGUID(false)..HttpService:GenerateGUID(false) 	return Abd end local _WAIT = false function TweenTp(...) 	local _speed=_G.TweenFlySpeed or 30 	local TFS = SettingsTable 	if not game.Players.LocalPlayer.Character then return end 	if _WAIT == false then 		_WAIT = true 		if TFS.TweenFly == true then 			sFLY(true) 		end 		if TFS.Twennnoclip == true then 			for _, child in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do 				if child:IsA("BasePart") and child.CanCollide == true and child.Name ~= floatName then 					child.CanCollide = false 				end 			end 		end 		local plr=game.Players.LocalPlayer 		local args={...} 		if typeof(args[1])=="number"and args[2]and args[3]then 			args=Vector3.new(args[1],args[2],args[3]) 		elseif typeof(args[1])=="Vector3" then 			args=args[1] 		elseif typeof(args[1])=="CFrame" then 			args=args[1].Position 		end 		if plr.Character:FindFirstChild("HumanoidRootPart") then 			local dist=(plr.Character:FindFirstChild("HumanoidRootPart").Position-args).Magnitude 			--[[ 			if dist > 100 then 				if TFS.TweenFast == true then 					_speed = math.random(25,30) 				end 			end 			]] 			local Tween = game:GetService("TweenService"):Create( 			plr.Character.HumanoidRootPart, 			TweenInfo.new(dist/_speed,Enum.EasingStyle.Linear), 			{CFrame=CFrame.new(args)} 			) 			CROPTWEEN22 = Tween 			LASTTWEEN = Tween 			Tween:Play() 			Tween.Completed:Connect(function() 				_WAIT = false 				if TFS.PlayerFly == false then 					NOFLY() 				end 				if TFS.Twennnoclip == true then 					for _, child in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do 						if child:IsA("BasePart") and child.CanCollide == false and child.Name ~= floatName then 							child.CanCollide = true 						end 					end 				end 				return true 			end) 			return Tween 		end 	end end function PathFindingSystem(dest) 	local serv = game:GetService("PathfindingService") 	local human = game.Players.LocalPlayer.Character.Humanoid 	local body = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or game.Players.LocalPlayer.Character:FindFirstChild("Torso") 	if dest == nil then return end 	if dest:IsA("Part") then else DebugCheck(0,"Fehler kein Part!") end 	local path = serv:CreatePath() 	path:ComputeAsync(body.Position,dest.Position) 	if path.Status == Enum.PathStatus.Success then 		local wayPoints = path:GetWaypoints() 		for i = 1,#wayPoints do 			local point = wayPoints[i] 			human:MoveTo(point.Position) 			local success = human.MoveToFinished:Wait() 			if point.Action == Enum.PathWaypointAction.Jump then 				human.WalkSpeed = 0 				wait(0.2) 				human.WalkSpeed = 16 				human.Jump = true 			end 			if not success then 				human.Jump = true 				human:MoveTo(point.Position) 				if not human.MoveToFinished:Wait() then 					break 				end 			end 		end 	end end function ChestAura() 	for i,Chest in pairs(GetIsland():FindFirstChild("Blocks"):GetChildren()) do 		if Chest:FindFirstChild("Contents") then 			for i,Tool in pairs(Chest:FindFirstChild("Contents"):GetChildren()) do 				local args = { 					[1] = { 						["chest"] = Chest, 						["player_tracking_category"] = "join_from_web", 						["amount"] = Tool:FindFirstChild("Amount").Value, 						["tool"] = Tool, 						["action"] = "withdraw" 					} 				} 				game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("CLIENT_CHEST_TRANSACTION"):InvokeServer(unpack(args)) 			end 		end 	end 	task.wait() end function GetTreeName(TreeArt) 	_G.ZahlenTree = false 	_G.OakSelected = false 	if TreeArt == "all" then 		return "tree" 	elseif TreeArt == "Oak" then 		_G.OakSelected = true 		return "tree" 	elseif TreeArt == "Birch" then 		return "treeBirch" 	elseif TreeArt == "Maple" then 		return "treeMaple" 	elseif TreeArt == "Pine" then 		return "treePine" 	elseif TreeArt == "Hickory" then 		return "treeHickory" 	elseif TreeArt == "Spirit" then 		_G.ZahlenTree = true 		return "treeSpirit" 	end end function IsSynapse() 	if (syn) then 		return true 	else 		return false 	end end function GetIsland() 	local FOUND = false 	local islandName 	local _________Inseln = game:GetService("Workspace").Islands:GetChildren() 	for i = 1, #_________Inseln do 		if _________Inseln[i]:FindFirstChild("Owners"):FindFirstChild(_G.Island_USERID) then 			islandName = _________Inseln[i] 			FOUND = true 			return islandName 		end 	end 	task.wait() 	if not FOUND then 		return game:GetService("Workspace").Islands:FindFirstChildWhichIsA("Model") 	end end function OwnISland() 	local islandName = GetIsland() 	local args = { 		[1] = { 			["island"] = islandName 		} 	} 	if islandName and islandName ~= nil then 		game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_VISIT_ISLAND_REQUEST:InvokeServer(unpack(args)) 	end end local SAVEDBlocksPos = {} function GetBlockUpdate() 	local Island = GetIsland() 	if Island then 		local Blocks = Island:FindFirstChild("Blocks") 		for i,v in pairs(Blocks:GetChildren()) do 			if v:IsA("Part") or v:IsA("MeshPart") then 				table.insert(SAVEDBlocksPos, v) 			end 		end 	end end GetBlockUpdate() function GetBlock(Name, Pos) 	if SAVEDBlocksPos == {} or SAVEDBlocksPos == nil then 		GetBlockUpdate() 	end 	local Island = GetIsland() 	local Blocks = Island:FindFirstChild("Blocks") 	if not Blocks then return nil end 	for i,v in ipairs(SAVEDBlocksPos) do 		if v:FindFirstChild("Health") then 			if Name == false then 				if v.Position == Pos then 					return v 				end 			else 				if v.Name == Name then 					if v.Position == Pos then 						return v 					end 				end 			end 		end 	end end function GetBlocks(position, size, Part) 	local mainPart 	if Part then 		mainPart = Part 	else 		local position = position or Vector3.new(0,0, 0) -- Ersetzen Sie die Position nach Bedarf 		local halfSize = size or Vector3.new(0,0,0) -- Regiongröße von 10x10x10 		-- Erstellen eines Parts und Platzierung innerhalb der Region 		mainPart = Instance.new("Part") 		mainPart.Size = halfSize 		mainPart.CFrame = CFrame.new(position) 		mainPart.Anchored = true 		mainPart.Parent = workspace 		mainPart.Transparency = 0.5 		mainPart.CanCollide = false 		-- Erstellen einer SelectionBox und Platzierung um die Region 		print("Erstellen einer SelectionBox und Platzierung um die Region") 		local selectionBox = Instance.new("SelectionBox") 		selectionBox.Adornee = mainPart 		selectionBox.LineThickness = 0.1 		selectionBox.Color3 = Color3.new(1, 0, 0) 		selectionBox.Transparency = 0.5 		selectionBox.Parent = mainPart 	end 	local FoundBlocks = {} 	-- Drucken der Blöcke innerhalb der Region mit ihren Namen 	local blockCount = 0 	for _, part in pairs(workspace:GetPartsInPart(mainPart)) do 		blockCount = blockCount + 1 		DebugCheck(0,"Block", blockCount, "Name:", part.Name, "Position:", part.Position) 		table.insert(FoundBlocks, part) 	end 	return FoundBlocks end function GetMobName(Mob) 	if Mob == "Slime" then 		return "slime" 	end end function Message(Title1, Context1, ButtonText1, DurationTime) 	Fluent:Notify({ 		Title = Title1, 		Content = Context1, 		Duration = DurationTime 	}) end local RemoteMobCooldown = false game:GetService("RunService").RenderStepped:Connect(function() 	if _G.MobRemoteSpamming == true then 		local MOB = _G.MobRemoteSpammingSelectedMob 		local args = { 			[1] = Hash(), 			[2] = { 				[1] = { 					["direction"] = Vector3.new(0,-90,0), -- MOB:FindFirstChild("HumanoidRootPart").Position 					["shootType"] = 0, 					["acaanSbvNqmvUwqyaPbPdbs"] = "\7\240\159\164\163\240\159\164\161\7\n\7\n\7\niDtnsvjyuiGm", 					["spellBook"] = game:GetService("Players").LocalPlayer.Character:FindFirstChildWhichIsA("Tool"), 					["charge"] = 1, 					["time"] = game.Workspace.DistributedGameTime 				} 			} 		} 		if RemoteMobCooldown == false then 			RemoteMobCooldown = true 			game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild("kthdgIcgPfwv/tyTrpdkeydznlntEvsjocmEixLw"):FireServer(unpack(args)) 			task.wait() 			RemoteMobCooldown = false 		end 	end end) function DoubleFarmMob(V) 	DebugCheck(0,"DoubleFarmMob") 	local SelectedMob 	local ISAMOB = false 	for i,v in pairs(_G.SelectedMobs) do 		task.wait() 		if game:GetService("Workspace").WildernessIsland.Entities:FindFirstChild(v) then 			if ISAMOB == false then 				ISAMOB = true 				SelectedMob = game:GetService("Workspace").WildernessIsland.Entities:FindFirstChild(v) 				DebugCheck(0,SelectedMob.Name) 			end 		end 	end 	if SelectedMob ~= nil and SelectedMob then 		local YVALUE = _G.MobTpYPos 		if SelectedMob:FindFirstChild("HumanoidRootPart") == nil then SelectedMob:Destroy() return end 		TeleportV4(SelectedMob:FindFirstChild("HumanoidRootPart").Position + Vector3.new(0,YVALUE,0)) 		for i = 1,3 do 			if SelectedMob then 				if SelectedMob:FindFirstChild("HumanoidRootPart") then 					TeleportV4(SelectedMob:FindFirstChild("HumanoidRootPart").Position + Vector3.new(0,YVALUE,0)) 					if CANUSEAUTOCLICKER == true then 						if _G.MobBookFarm == true then 							_G.MobRemoteSpammingSelectedMob = SelectedMob 							_G.MobRemoteSpamming = true 						else 							game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, 1) 							task.wait() 							game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, game, 1) 						end 					end 					if _G.MobBookFarm == false then 						if 	SelectedMob:FindFirstChild("HumanoidRootPart") then 							--[[ 														if SelectedMob:FindFirstChild("Humanoid") then 								SelectedMob:FindFirstChild("Humanoid"):Destroy() 							end 							]] 							--SelectedMob:FindFirstChild("HumanoidRootPart").Size = Vector3.new(8,YVALUE+4,8) 							--SelectedMob:FindFirstChild("HumanoidRootPart").CanCollide = false 						end 					end 					task.wait() 				end 			end 		end 	end end local MOBSWORDBYPASSED = false local ANTIBANMOB = false local ANTICONSOLEWARNLOGANIMATION = false local LastMob = nil game:GetService("RunService").RenderStepped:Connect(function() 	if _G.AutoFarm == true or _G.BossAutoFarm == true then	 		if LastMob and LastMob:FindFirstChild("Humanoid") and LastMob:FindFirstChild("Humanoid").Health > 0 and LastMob:FindFirstChild("HumanoidRootPart") then 			local YVALUE = _G.MobTpYPos 			TeleportV4(LastMob:FindFirstChild("HumanoidRootPart").Position + Vector3.new(0,YVALUE,0)) 		end 	end end) function FarmMob(V) 	print("FarmMob:",V) 	local function findNearestMob(A) 		local closestPart = nil 		local closestDistance = math.huge 		local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 		local Table = A 		for i, part in ipairs(Table) do 			local distance = (part:FindFirstChild("HumanoidRootPart").Position - playerPosition).magnitude 			if distance < closestDistance then 				closestPart = part 				closestDistance = distance 			end 		end 		DebugCheck(0,"findNearestPart") 		return closestPart 	end 	if _G.AutoFarm == false and _G.BossAutoFarm == false then return nil end 	DebugCheck(0,"FarmMob") 	local SelectedMob 	local MobsToScan = {} 	if V == true then 		SelectedMob = game:GetService("Workspace").WildernessIsland.Entities:FindFirstChild(_G.SelectedBoss) 	else 		for i,v in pairs(game:GetService("Workspace").WildernessIsland.Entities:GetChildren()) do 			if v and v:FindFirstChild("Humanoid") and v:FindFirstChild("HumanoidRootPart") then 				print("HUMANOID/ROOTAPRT") 				if type(_G.SelectedMob) == "table" then 					for i,x in pairs(_G.SelectedMob) do 						if v.Name == x then 							print("ADDED!",v.Name) 							table.insert(MobsToScan, v) 						else 							print("x ist:",x.." Mob heißt:",v) 						end 					end 				else 					if v.Name == _G.SelectedMob then 						print("ADDED!",v.Name) 						table.insert(MobsToScan, v) 					else 						print(v.Name) 					end 				end 			end 		end 		SelectedMob = findNearestMob(MobsToScan) 		print("NEWMOB:",SelectedMob) 	end 	if SelectedMob ~= nil and SelectedMob then 		LastMob = SelectedMob 		print(0,"Farm Mob:", SelectedMob.Name) 		local YVALUE = _G.MobTpYPos 		task.spawn(function() 			TeleportV4(SelectedMob:FindFirstChild("HumanoidRootPart").Position + Vector3.new(0,YVALUE,0)) 		end) 		print(0,"MOB FARM ON TOP!") 		if MOBSWORDBYPASSED == false then 			if _G.ragebladeMobFarm == true then 				local success, result = pcall(function() 					local aux = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Upbolt/Hydroxide/revision/ohaux.lua"))() 					local Tool = game:GetService("Players").LocalPlayer.Character:FindFirstChild("rageblade") 					if Tool then 						local aux = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Upbolt/Hydroxide/revision/ohaux.lua"))() 						local scriptPath = Tool:FindFirstChild("rageblade") 						local closureName = "Unnamed function" 						local upvalueIndex = 1 						local closureConstants = { 							[1] = "isHitting", 							[2] = "getLivingEntityFromChildPart", 							[3] = "attemptHit" 						} 						print("scriptPath:",scriptPath) 						local closure = aux.searchClosure(scriptPath, closureName, upvalueIndex, closureConstants) 						local value = 0 						local elementIndex = "lastClicked" 						game:GetService("RunService").RenderStepped:Connect(function() 							debug.getupvalue(closure, upvalueIndex)[elementIndex] = value 						end) 					end 					-- Generated by Hydroxide's Upvalue Scanner: https://github.com/Upbolt/Hydroxide 					local aux = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Upbolt/Hydroxide/revision/ohaux.lua"))() 					local Tool = game:GetService("Players").LocalPlayer.Character:FindFirstChild("rageblade") 					if Tool then 						local scriptPath = Tool:FindFirstChild("rageblade") 						local closureName = "Unnamed function" 						local upvalueIndex = 1 						local closureConstants = { 							[1] = "isHitting", 							[2] = "getLivingEntityFromChildPart", 							[3] = "attemptHit" 						} 						local closure = aux.searchClosure(scriptPath, closureName, upvalueIndex, closureConstants) 						local value = 4 						local elementIndex = "speed" 						debug.getupvalue(closure, upvalueIndex)[elementIndex] = value 						MOBSWORDBYPASSED = true 					end 				end) 			end 		end 		for i = 1,1 do 			if _G.AutoFarm == false and _G.BossAutoFarm == false then return end 			if SelectedMob then 				if SelectedMob:FindFirstChild("HumanoidRootPart") then 					TeleportV4(SelectedMob:FindFirstChild("HumanoidRootPart").Position + Vector3.new(0,YVALUE,0)) 					if CANUSEAUTOCLICKER == true then 						if _G.MobBookFarm == true then 							_G.MobRemoteSpammingSelectedMob = SelectedMob 							_G.MobRemoteSpamming = true 						else 							--if ANTIBANMOB == false then 							--	ANTIBANMOB = true 							task.spawn(function() 								if ANTICONSOLEWARNLOGANIMATION == false then 									ANTICONSOLEWARNLOGANIMATION = true 									for i,v in pairs(game:GetService('Players'):GetChildren()) do 										if v and v.Character and v.Character:FindFirstChild("Humanoid") then 											Player = v.Name 											AnimationId = "5328169716" 											local Anim = Instance.new("Animation") 											Anim.AnimationId = "rbxassetid://"..AnimationId 											local k = game.Players[Player].Character.Humanoid:LoadAnimation(Anim) 											k:Play() --Play the animation 											k:AdjustSpeed(0) 											task.spawn(function() 												task.wait(8) 												Anim:Destroy() 											end)	 												--[[ 												if _G.MobFarmAnimationBypass == true then 													k:AdjustSpeed(0) 												else 													k:AdjustSpeed(1) 												end 												]] 										end 									end 									task.wait(1) 									ANTICONSOLEWARNLOGANIMATION = false 								end 							end) 								--[[ 								game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, 1) 								game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, game, 1) 								]] 							task.wait(0.5) 							local args = { 								[1] = Hash(), 								[2] = { 									[1] = { 										[MotHitH1] = MotHitH2, 										["hitUnit"] = SelectedMob 									} 								} 							} 							if _G.ragebladeMobFarm == true then 								for i = 1,50 do 									game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("KillRemote").Value):FireServer(unpack(args)) 									task.wait() 								end 							else 								for i = 1,5 do 									game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("KillRemote").Value):FireServer(unpack(args)) 									task.wait(0.3) 								end 							end 							--ANTIBANMOB = false 							--end 						end 					end 				end 			end 		end 	else 		print("No SelectedMob!") 	end end function GetProxNameFromBoss(BossName) 	if BossName == "slimeKing" then 		return "slime_king_spawn" 	elseif BossName == "slimeQueen" then 		return "slime_queen_spawn" 	elseif BossName == "desertBoss" then 		return "desert_boss_spawn" 	elseif BossName == "golem" then 		return "golem_spawn" 	end end function SpawnBoss(BossName) 	if BossName then 		local PProx = game:GetService("Workspace").spawnPrefabs.WildEventTriggers:FindFirstChild(BossName) 		if PProx then 			local RealProx = PProx:FindFirstChild("ProximityPrompt") 			if RealProx then 				TeleportV4(PProx.Position) 				fireproximityprompt(RealProx) 			end 		end 	end end local BossCheckCOOLDOWN = false function BossCheck(BossName) 	if BossCheckCOOLDOWN == false then 		BossCheckCOOLDOWN = true 		local SelectedMob = game:GetService("Workspace").WildernessIsland.Entities:FindFirstChild(BossName) 		if SelectedMob then 			FarmMob(true) 		else 			if _G.BossAutoSpawn == true then 				SpawnBoss(GetProxNameFromBoss(BossName)) 			else 				print("Auto Spawn ist off, ich warte dann mal ^^") 			end 		end 		task.wait(0.1) 		BossCheckCOOLDOWN = false 	end end local CropAntiLag = false function CropFarm(TP) 	if CropAntiLag == false then 		CropAntiLag = true 		local Island = GetIsland() 		local Blocks = Island:FindFirstChild("Blocks") 		local ToFarm = {} 		local ReplaceCFrame = {} 		local Count = 1 		local CC = 0 		for i,v in pairs(Blocks:GetChildren()) do 			if v.Name == _G.SelectedCrop then 				local dis = (v.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 				local MAXDIS = _G.SichleCropRange or 30 				if dis < MAXDIS then 					--table.insert(ToFarm, v) -- add the light 					CC = CC +1 					ToFarm[CC] = v 					ReplaceCFrame[CC] = v.CFrame 				end 			end 		end 		if TP == true then 			if Blocks:FindFirstChild(_G.SelectedCrop) then 				local A = Blocks:FindFirstChild(_G.SelectedCrop) 				TeleportV4(A.Position) 				task.wait(0.5) 			end 		end 		for i,v in pairs(ToFarm) do 			local H1 = RemoteData:FindFirstChild("CropHashData").Value 			local H2 = _G.CropHash 			local ohTable1 = { 				[H1] = H2, 				["player"] = game:GetService("Players").LocalPlayer, 				["model"] = ToFarm[Count] 			} 			task.wait() 			game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_HARVEST_CROP_REQUEST:InvokeServer(ohTable1) 			Count = Count + 1 		end 		task.wait() 		for i,v in ipairs(ReplaceCFrame) do		 			local ohTable1 = { 				["upperBlock"] = false, 				["cframe"] = v, 				["blockType"] = "wheat", 				[PlaceHASHName] = CropPlaceH2 			} 			if _G.AutoReplaceCrop == true then 				game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_PLACE_REQUEST:InvokeServer(ohTable1) 			end 			v = nil 		end 	end 	task.wait(5) 	CropAntiLag = false end local AutoCollectFruitsCooldown = false function AutoCollectFruits() 	if AutoCollectFruitsCooldown == false then 		AutoCollectFruitsCooldown = true 		local Island = GetIsland() 		for i,v in pairs(Island:FindFirstChild("Blocks"):GetChildren()) do 			if v:FindFirstChild("FruitLocations") then 				for i,v in pairs(v:FindFirstChild("FruitLocations"):GetChildren()) do 					if v:IsA("Part") then 						if v:FindFirstChild("Targettable") then 							if v:FindFirstChildWhichIsA("Tool") then 								local dis = (v.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 								if dis < 30 then 									local args = { 										[1] = { 											["tool"] = v:FindFirstChildWhichIsA("Tool"), 											[PickupH1] = PickupH2 										} 									} 									game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.CLIENT_TOOL_PICKUP_REQUEST:InvokeServer(unpack(args)) 								else 									repeat TeleportV4(v.Position) 										local args = { 											[1] = { 												["tool"] = v:FindFirstChildWhichIsA("Tool"), 												[PickupH1] = PickupH2 											} 										} 										game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.CLIENT_TOOL_PICKUP_REQUEST:InvokeServer(unpack(args)) 										task.wait(1) 									until v:FindFirstChildWhichIsA("Tool") == nil 								end 							end 						end 					end 				end 			end 		end 		task.wait() 		AutoCollectFruitsCooldown = false 	end end local FishFarmCooldown = false function FishFarm() 	local dis = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(-91, 29, -897)).Magnitude 	if dis > 30 then 		TeleportV4(Vector3.new(-91, 34, -897)) 		repeat wait() until (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(-91, 29, -897)).Magnitude < 5 		task.wait(0.5) 	end 	if FishFarmCooldown == false then 		FishFarmCooldown = true 		local args = { 			[1] = Hash(), 			[2] = { 				[1] = { 					["playerLocation"] = Vector3.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position), 					["direction"] = Vector3.new(-0.9983646869659424, -9.509330567425422e-08, 0.057165950536727905), 					["strength"] = math.random(0.5, 2) 				} 			} 		} 		game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("AngelRemote").Value):FireServer(unpack(args)) 		task.wait(math.random(13,15)) 		local args = { 			[1] = { 				["success"] = true 			} 		} 		game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("FishFarmFinishRemote").Value):FireServer(unpack(args)) 	--[[ 		local args = { 		[1] = Hash(), 		[2] = { 			[1] = {} 		} 	} 	 	game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild("jmqvFcP/dgikodtTfngoBWdtu"):FireServer(unpack(args)) 	 	]] 		if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then 			game.Players.LocalPlayer.Character:FindFirstChild("Humanoid").Jump = true 		end 		task.wait(math.random(0.1,0.3)) 		FishFarmCooldown = false 	end end	 -- Funktion zum Finden des nächsten Teils local function findNearestPart(A) 	local closestPart = nil 	local closestDistance = math.huge 	local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 	local Table = A 	for i, part in ipairs(Table) do 		local distance = (part.Position - playerPosition).magnitude 		if distance < closestDistance then 			closestPart = part 			closestDistance = distance 		end 	end 	DebugCheck(0,"findNearestPart") 	return closestPart end local AutoCollectTotemItemsCooldown = false function AutoCollectTotemItems() 	if _G.AutoCollectTotemItems == true then 		if AutoCollectTotemItemsCooldown == false then 			AutoCollectTotemItemsCooldown = true 			local Island = GetIsland() 			if Island and Island:FindFirstChild("Blocks") then 				local Totems = {} 				for i,v in pairs(Island:FindFirstChild("Blocks"):GetChildren()) do 					local Items = v:FindFirstChild("WorkerContents") 					if Items and Items:FindFirstChildWhichIsA("Tool") then 						if v.Name == _G.SelectedTotem then 							table.insert(Totems, v) 						end 					end 				end 				local Totem = findNearestPart(Totems) 				if Totem then 					local v = Totem 					TeleportV4(v.Position) 					repeat wait() until (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude < 3 					repeat 						for i,v in pairs(v:FindFirstChild("WorkerContents"):GetChildren()) do 							local args = { 								[1] = { 									["tool"] = v, 									[PickupH1] = PickupH2 								} 							} 							game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.CLIENT_TOOL_PICKUP_REQUEST:InvokeServer(unpack(args)) 							task.wait() 						end	 						task.wait(0.3) 					until v:FindFirstChild("WorkerContents") == nil or v:FindFirstChild("WorkerContents"):FindFirstChildWhichIsA("Tool") == nil 					task.wait(1) 				end 			end 		end 		task.wait(2) 		AutoCollectTotemItemsCooldown = false 	end end local TFCO = false local RemoteAntiBan = false function TreeFarm(TP)	 	local NE = {} 	if TFCO == true then return nil end 	TFCO = true 	if TP == true then 		DebugCheck(0,"TreeFarm (true)") 	else 		DebugCheck(0,"Tree Farm (false)") 	end 	if _G.SelectedTree == "all" then 		_G.SelectedTree = "tree" 	else 	end 	if _G.SelectedTree == "Oak" then 		DebugCheck(0,"IST OAK!!!") 	end 	DebugCheck(0,"JOA") 	DebugCheck(0,_G.SelectedTree) 	-- Funktion zum Finden des nächsten Teils 	local function findNearestPart(A) 		local closestPart = nil 		local closestDistance = math.huge 		local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 		local Table = A 		for i, part in ipairs(Table) do 			local distance = (part.Position - playerPosition).magnitude 			if distance < closestDistance then 				closestPart = part 				closestDistance = distance 			end 		end 		DebugCheck(0,"findNearestPart") 		return closestPart 	end 	local distance = 35000 	for i,v in pairs(GetIsland().Blocks:GetChildren()) do 		local Art = string.sub(v.Name:lower(), 1, string.len(_G.SelectedTree)) 		--if (Art == _G.SelectedTree) then 		if string.match(v.Name, _G.SelectedTree) then 			if 	_G.OakSelected == true then 				DebugCheck(0,"isTreeWithNumber") 				local isTreeWithNumber = string.match(v.Name, "^tree%d+$") 				DebugCheck(0,"ADD22???",v.name) 				if isTreeWithNumber then 					DebugCheck(0,"ADD22",v.name) 					table.insert(NE, v) 				end 			elseif _G.ZahlenTree == true then 				local isTreeWithNumber = string.match(v.Name, "^".._G.SelectedTree.."%d+$") 				if isTreeWithNumber then 					DebugCheck(0,"ADD35",v.name) 					table.insert(NE, v) 				end 			else 				DebugCheck(0,"ADD",v.name) 				table.insert(NE, v) 			end 		end 		-- end 	end	 	local v = findNearestPart(NE) 	DebugCheck(0,v) 	if v then 		local mag = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude 		if mag < distance then 			if _G.TreeAutoFarm == false and _G.TreeAura == false then return end 		--[[ 				if TP == true then 			task.spawn(function() 				TeleportV4(v.Position + Vector3.new(0,0,6)) 			end) 		end 		]] 			local T = v 			local H1 = RemoteData:FindFirstChild("TreeHashData").Value 			local H2 = _G.TreeHash 			local TFOUND = v:FindFirstChild("trunk") or v:FindFirstChildWhichIsA("MeshPart") 			local args1 = { 				[H1] = H2, 				["part"] = TFOUND, 				["block"] = v, 				["norm"] = Vector3.new(v.CFrame), 				["pos"] = v.Position 			} 			if v == nil then TFCO = false return end 			if TFOUND == nil then TFCO = false return end 		--[[ 		if TP == true then 			task.spawn(function() 			TeleportV4(v.Position + Vector3.new(0,0,6)) 			end) 		end 		]] 			if v == nil then TFCO = false return end 			if TFOUND == nil then TFCO = false return end 			while TFOUND do 				if v then 					task.wait() 					for i = 1,10 do 						if v ~= nil then 							if _G.TreeAutoFarm == false and _G.TreeAura == false then TFCO = false return end 							if not v or v == nil then TFCO = false return end 							if not TFOUND then TFCO = false return end 							task.wait() 							if RemoteAntiBan == false then 								RemoteAntiBan = true 								if TP == true then 									TeleportV4(v.Position + Vector3.new(0,0,6)) 									task.wait() 								end 								game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_HIT_REQUEST:InvokeServer(args1) 								-- task.wait() 								if v:FindFirstChild("trunk") or v:FindFirstChildWhichIsA("MeshPart") then 								else 									TFOUND = nil 								end 								RemoteAntiBan = false 							end 						end 					end 				else 					task.wait(0.2) 					TFCO = false 					break 				end 			end 		else 			OwnISland() 		end	 	end 	task.wait(0.8) 	TFCO = false end function ROCKHELPER_1() 	local ohTable1 = { 		[HitHASHName] = HitHASH, 		["part"] = _G.Now_Rock_part, 		["block"] = _G.Now_Rock_block, 		["norm"] = _G.Now_Rock_norm, 		["pos"] = _G.Now_Rock_pos, 	} 	for i = 1,1 do 		if _G.Now_Rock_part then 			game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("BlockRemote").Value):InvokeServer(ohTable1) 		end 	end end local IslandRockFarmCOOLDOWN = false function IslandRockFarm(RockArt) 	if IslandRockFarmCOOLDOWN == false then 		IslandRockFarmCOOLDOWN = true 		print("IslandRockFarm") 		-- if _G.RockFarmonIsland ~= true then return nil end 		local function findNearestRock(A) 			local closestPart = nil 			local closestDistance = math.huge 			local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 			local Table = A 			for i, part in ipairs(Table) do 				task.wait() 				local distance = (part.Position - playerPosition).magnitude 				if distance < closestDistance then 					closestPart = part 					closestDistance = distance 				end 			end 			return closestPart 		end 		local Island = GetIsland() 		local Blocks = Island:FindFirstChild("Blocks") 		local RocksSaved = {} 		if type(RockArt) == "table" then 			for i,v in pairs(Blocks:GetChildren()) do 				function removeRock(itemName) 					task.wait() 					local index = string.find(itemName, "rock") 					if index ~= nil then 						return string.sub(itemName, 1, index - 1) .. string.sub(itemName, index + 4) 					else 						return itemName 					end 				end	 				local Name = removeRock(v.Name) 				local isALL = false 				if RockArt == "All" or table.find(RockArt,"All") then 					task.wait() 					if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then 						task.wait() 						table.insert(RocksSaved, v) 						isALL = true 					end 				end 				if table.find(RockArt,Name) and isALL == false then 					task.wait() 					if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then 						task.wait() 						table.insert(RocksSaved, v) 					end 				end 			end 		else 			if RockArt == "All"then 				for i,v in pairs(Blocks:GetChildren()) do 					if v:FindFirstChild("1") then 						if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then 							if _G.RockFarmonIsland ~= true then return nil end 							table.insert(RocksSaved, v) 						end 					end 				end 			else 				for i,v in pairs(Blocks:GetChildren()) do 					if v.Name == RockArt then 						if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then 							if _G.RockFarmonIsland ~= true then return nil end 							table.insert(RocksSaved, v) 						end 					end 				end 			end 		end 		print("HOL DEN BLOCK!!!") 		local v = findNearestRock(RocksSaved) 		if v then 			print("V gefunden!!!", v.Name) 			-- if _G.RockFarmonIsland ~= true then return nil end 			local dis = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude 			print("DISTANCE") 			if dis > 20 then 				print("YES") 				if v then 					TeleportV4(v.Position) 					repeat wait() until (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude < 20 					task.wait() 					local ohTable1 = { 						[HitHASHName] = HitHASH, 						["part"] = v:FindFirstChild("1") or v, 						["block"] = v, 						["norm"] = Vector3.new(v.CFrame), 						["pos"] = v.Position 					} 					game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("BlockRemote").Value):InvokeServer(ohTable1) 				else 					v = nil 				end 			else 				print("NOPE") 				if v then 					print("Es gibt v schicke remote") 					local ohTable1 = { 						[HitHASHName] = HitHASH, 						["part"] = v:FindFirstChild("1") or v, 						["block"] = v, 						["norm"] = Vector3.new(v.CFrame), 						["pos"] = v.Position 					} 					game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("BlockRemote").Value):InvokeServer(ohTable1) 				else 					v = nil 				end 			end 		else 			warn("Kein Block!!!") 		end 	end 	task.wait(1) 	print("WAIT 1 ist UM!!!") 	IslandRockFarmCOOLDOWN = false end local RF = false function RockFarm(RockArt, T) 	if RF == false then 		RF = true 		if _G.RockFarmonIsland == true then 			IslandRockFarm(RockArt) 			time.sleep(1) 			RF = false 			return 		end 		local NowName = RockArt 		local Rocks = {} 		local function findNearestRock(A) 			local closestPart = nil 			local closestDistance = math.huge 			local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 			local Table = A 			for i, part in ipairs(Table) do 				local distance = (part.Position - playerPosition).magnitude 				if distance < closestDistance then 					closestPart = part 					closestDistance = distance 				end 			end 			DebugCheck(0,"findNearestPart") 			return closestPart 		end 		function IsInTable(Table, NameToCheck) 			task.wait() 			if NameToCheck and Table then 				if type(Table) == "table" then 					if table.find(Table, NameToCheck) then 						return true 					else 						return false 					end 				else 					if type(Table) == "string" then 						if Table == NameToCheck then 							return true 						else 							return false 						end 					end 				end 			else 				if NameToCheck == nil then 					print("NameToCheck is nil") 				end 				if Table == nil then 					print("Table is nil") 				end 				return false 			end 		end 		if T == "T" then 			for i,v in pairs(game:GetService("Workspace").WildernessBlocks:GetChildren()) do 				function removeRock(itemName) 					local index = string.find(itemName, "rock") 					if index ~= nil then 						return string.sub(itemName, 1, index - 1) .. string.sub(itemName, index + 4) 					else 						return itemName 					end 				end			 				local Name = removeRock(v.Name) 				if RockArt == "All" or table.find(RockArt, "All") then 					table.insert(Rocks, v) 				else 					if table.find(RockArt, Name) then 						table.insert(Rocks, v) 					end 				end 			end 		else 			if RockArt == "All" then 				for i,v in pairs(game:GetService("Workspace").WildernessBlocks:GetChildren()) do 					table.insert(Rocks, v) 				end 			else 				for i,v in pairs(game:GetService("Workspace").WildernessBlocks:GetChildren()) do 					if v.Name == RockArt then 						table.insert(Rocks, v) 					end 				end 			end 		end 		local Rock = findNearestRock(Rocks) 		if not Rock then RF = false return end 		if Rock then 			if Rock.Position and Rock:FindFirstChild("0") or Rock:FindFirstChild("1") then 				TeleportV4(Rock.Position) 				repeat wait() 					TeleportV4(Rock.Position) 					local ohTable1 = { 						[HitHASHName] = HitHASH, 						["part"] = Rock:FindFirstChild("0") or Rock:FindFirstChild("1"), 						["block"] = Rock, 						["norm"] = Vector3.new(Rock.CFrame), 						["pos"] = Vector3.new(Rock:FindFirstChild("0").Position) or Vector3.new(Rock:FindFirstChild("1").Position) 					} 					game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("BlockRemote").Value):InvokeServer(ohTable1)	 				until Rock == nil or Rock:FindFirstChild("0") == nil or Rock:FindFirstChild("1") == nil 				RF = false 			end 		end 		RF = false 	end end function RockFarmV2(RockArt, b1,b2,b3) 	print("1. RockArt:",RockArt) 	if type(RockArt) == "table" then 		-- print("IST EIN TABLE!!!") 		if table.find(RockArt, "All") then 			print("ALL!!!") 			RockFarm("All", "T") 		else 			RockFarm(RockArt, "T") 		end 	else 		if RockArt == "All" then 			RockFarm("All") 		elseif RockArt == "Iron" then 			RockFarm("rockIron") 		elseif RockArt == "Gold" then 			RockFarm("rockGold") 		elseif RockArt == "Diamond" then 			RockFarm("rockDiamond") 		elseif RockArt == "Amethyst Stone" then 			RockFarm("rockAmethystStone") 		elseif RockArt == "Amethyst" then 			RockFarm("rockAmethyst") 		elseif RockArt == "Obsidian" then 			RockFarm("rockObsidian") 		elseif RockArt == "Opal" then 			RockFarm("rockOpal") 		elseif RockArt == "Copper" then 			RockFarm("rockCopper") 		elseif RockArt == "Diorite" then 			RockFarm("rockDiorite") 		elseif RockArt == "Coal" then 			RockFarm("rockCoal") 		elseif RockArt == "Stone" then 			RockFarm("rockStone") 		elseif RockArt == "Electrite" then 			RockFarm("rockElectrite") 		else 			function removeRock(itemName) 				local index = string.find(itemName, "rock") 				if index ~= nil then 					return string.sub(itemName, 1, index - 1) .. string.sub(itemName, index + 4) 				else 					return itemName 				end 			end	 			RockFarm(removeRock(RockArt)); 		end 	end end function RockAura() 	local ToBreak = {} 	local Count = 1 	for i,v in pairs(game:GetService("Workspace").WildernessBlocks:GetChildren()) do 		local mag = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude 		if mag < 30 then 			ToBreak[Count] = v 			Count = Count + 1 		end 	end 	-- game:GetService("Workspace").WildernessBlocks 	for i,v in pairs(ToBreak) do 		local args0 = { 			[1] = { 				[HitHASHName] = HitHASH, 				["part"] = v:FindFirstChild("1"), 				["block"] = v, 				["norm"] = Vector3.new(v.CFrame), 				["pos"] = v:FindFirstChild("1").Position 			} 		} 		local args1 = { 			[1] = { 				[HitHASHName] = HitHASH, 				["part"] = v:FindFirstChild("1"), 				["block"] = v, 				["norm"] = Vector3.new(v.CFrame), 				["pos"] = v:FindFirstChild("1").Position 			} 		} 		if v:FindFirstChild("1") then 			game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_HIT_REQUEST:InvokeServer(unpack(args1)) 		elseif v:FindFirstChild("0") then 			game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_HIT_REQUEST:InvokeServer(unpack(args0)) 		else 			DebugCheck(0,"Fehler!") 		end 	end 		--[[ 	for i,v in pairs(game:GetService("Workspace").WildernessBlocks:GetChildren()) do 			if v:IsA("Part") then DebugCheck(0,"RICHTIG!") else DebugCheck(0,"FALSCH") return nil end 			local mag = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude 			if mag > 30 then DebugCheck(0,"ZU WEIT WEG!") return end 			DebugCheck(0,v.Name) 			if not v then DebugCheck(0,"v not found!") return end 			if not v:FindFirstChild("1") then DebugCheck(0,"1 nicht gefunden!") return end 			local args = { 				[1] = { 					["player_tracking_category"] = "join_from_web", 					["part"] = v:FindFirstChild("1"), 					["block"] = v, 					["norm"] = Vector3.new(v.CFrame), 					["pos"] = Vector3.new(v:FindFirstChild("1").Position) 				} 			} 			if mag < 30 then 				if not v then return end 				if not v:FindFirstChild("1") then return end 				game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_HIT_REQUEST:InvokeServer(unpack(args)) 				task.wait() 		end 	end 	--]] end -- AURA -- local F if game:FindFirstChild("CROPBETA") == nil then 	local C = Instance.new("Folder") 	C.Parent = game 	C.Name = "CROPBETA" 	F = C else 	F = game:FindFirstChild("CROPBETA") end task.wait() function Set(POS) 	if F ~= nil then 		local A = Instance.new("ObjectValue") 		A.Value = POS 		A.Parent = F 	else 		game.Players.LocalPlayer:Kick("Error Please Reexecute!") 	end end function GetIsland() 	local islandName 	local _________Inseln = game:GetService("Workspace").Islands:GetChildren() 	for i = 1, #_________Inseln do 		if _________Inseln[i]:FindFirstChild("Owners"):FindFirstChild(_G.Island_USERID) then 			islandName = _________Inseln[i] 			return islandName 		end 	end end local KILLAURA_COOLDOWN = false function KillAuraOLD() 	if KILLAURA_COOLDOWN == false then 		KILLAURA_COOLDOWN = true 		local YVALUE = _G.MobTpYPos 		if workspace:FindFirstChild("WildernessIsland"):FindFirstChild("Entities") then 			local CHILDEN = workspace:FindFirstChild("WildernessIsland"):FindFirstChild("Entities"):GetChildren() 			for i = 1,#CHILDEN do 				if _G.ragebladeMobFarm == true then 					DebugCheck(0,"ragebladeMobFarm") 					local aux = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Upbolt/Hydroxide/revision/ohaux.lua"))() 					local Tool = game:GetService("Players").LocalPlayer.Character:FindFirstChild("rageblade") 					if Tool then 						local scriptPath = Tool:FindFirstChild("rageblade") -- Hier ist der error von Gestern. 						local closureName = "Unnamed function" 						local upvalueIndex = 1 						local closureConstants = { 							[1] = "isHitting", 							[2] = "getLivingEntityFromChildPart", 							[3] = "attemptHit" 						} 						local closure = aux.searchClosure(scriptPath, closureName, upvalueIndex, closureConstants) 						local value = 0 						local elementIndex = "lastClicked" 						-- DO NOT RELY ON THIS FEATURE TO PRODUCE 100% FUNCTIONAL SCRIPTS 						game:GetService("RunService").RenderStepped:Connect(function() 							debug.getupvalue(closure, upvalueIndex)[elementIndex] = value 						end) 					end 					-- Generated by Hydroxide's Upvalue Scanner: https://github.com/Upbolt/Hydroxide 					local aux = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Upbolt/Hydroxide/revision/ohaux.lua"))() 					local Tool = game:GetService("Players").LocalPlayer.Character:FindFirstChild("rageblade") 					if Tool then 						local scriptPath = Tool:FindFirstChild("rageblade") -- Hier ist der error von Gestern. 						local closureName = "Unnamed function" 						local upvalueIndex = 1 						local closureConstants = { 							[1] = "isHitting", 							[2] = "getLivingEntityFromChildPart", 							[3] = "attemptHit" 						} 						local closure = aux.searchClosure(scriptPath, closureName, upvalueIndex, closureConstants) 						local value = 4 						local elementIndex = "speed" 						debug.getupvalue(closure, upvalueIndex)[elementIndex] = value 					end 				end 				if _G.ragebladeMobFarm == true then 					DebugCheck(0,"ragebladeMobFarm2") 					if CHILDEN[i]:FindFirstChild("HumanoidRootPart") then 						if (CHILDEN[i]:FindFirstChild("HumanoidRootPart").Position - game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position).Magnitude < 30 then 							if CANUSEAUTOCLICKER == true then 								game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, 1) 								task.wait() 								game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, game, 1) 							end 							local ohString1 = Hash() 							local ohTable2 = { 								[1] = { 									[MotHitH1] = MotHitH2, 									["hitUnit"] = CHILDEN[i] 								} 							} 							local SelectedMob = CHILDEN[i] 							if 	CHILDEN[i]:FindFirstChild("HumanoidRootPart") then 								game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("KillRemote").Value):FireServer(ohString1, ohString2) 							else 								-- warn("No HumanoidRootPart") 							end 						end 					else 						if CANUSEAUTOCLICKER == true then 							game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, 1) 							task.wait() 							game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, game, 1) 						end 						local SelectedMob = CHILDEN[i] 						if 	CHILDEN[i]:FindFirstChild("HumanoidRootPart") then 							--[[ 							if SelectedMob:FindFirstChild("Humanoid") then 								SelectedMob:FindFirstChild("Humanoid"):Destroy() 							end 							]] 							--SelectedMob:FindFirstChild("HumanoidRootPart").Size = Vector3.new(8,YVALUE+4,8) 							--SelectedMob:FindFirstChild("HumanoidRootPart").CanCollide = false 						end 					end 				else 					if CHILDEN[i]:FindFirstChild("HumanoidRootPart") then 						if (CHILDEN[i]:FindFirstChild("HumanoidRootPart").Position - game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position).Magnitude < 30 then 							if CANUSEAUTOCLICKER == true then 								game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, 1) 								task.wait() 								game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, game, 1) 							end 							local SelectedMob = CHILDEN[i] 							if 	CHILDEN[i]:FindFirstChild("HumanoidRootPart") then 								--SelectedMob:FindFirstChild("HumanoidRootPart").Size = Vector3.new(8,YVALUE+4,8) 								--SelectedMob:FindFirstChild("HumanoidRootPart").CanCollide = false 							end 						end 					else 						if CANUSEAUTOCLICKER == true then 							game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, 1) 							task.wait() 							game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, game, 1) 						end 						local SelectedMob = CHILDEN[i] 						if 	CHILDEN[i]:FindFirstChild("HumanoidRootPart") then 							--[[ 							if SelectedMob:FindFirstChild("Humanoid") then 								SelectedMob:FindFirstChild("Humanoid"):Destroy() 							end 							]] 							--SelectedMob:FindFirstChild("HumanoidRootPart").Size = Vector3.new(8,YVALUE+4,8) 							--SelectedMob:FindFirstChild("HumanoidRootPart").CanCollide = false 						end 					end 				end 			end 		end 		task.wait(0.5) 		KILLAURA_COOLDOWN = false 	end end function NKillAura() 	if KILLAURA_COOLDOWN == false then 		KILLAURA_COOLDOWN = true 		local function findNearestPart(A) 			local closestPart = nil 			local closestDistance = math.huge 			local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 			local Table = A 			for i, part in ipairs(Table) do 				local distance = (part:FindFirstChild("HumanoidRootPart").Position - playerPosition).magnitude 				if distance < closestDistance then 					closestPart = part 					closestDistance = distance 				end 			end 			DebugCheck(0,"findNearestPart") 			return closestPart 		end 		local Mobs = {} 		for i,v in pairs(workspace.WildernessIsland.Entities:GetChildren()) do 			if v and v:FindFirstChild("HumanoidRootPart") then 				table.insert(Mobs, v) 			end 		end 		local NM = findNearestPart(Mobs) 		DebugCheck(0,NM.Name) 		-- game.Players.LocalPlayer.Character:MoveTo(NM:FindFirstChild("HumanoidRootPart").Position) 		for i = 1,50 do 			if NM then 				local ohString1 = Hash() 				local ohTable2 = { 					[1] = { 						[MotHitH1] = MotHitH2, 						["hitUnit"] = NM 					} 				} 				game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("KillRemote").Value):FireServer(ohString1, ohTable2) 				wait() 			end 		end 		task.wait(0.5) 		KILLAURA_COOLDOWN = false 	end end local KILLAURA_COOLDOWN = false local BypassedSowrd = false local ANTICONSOLEWARNLOGANIMATION2 = false function KillAura() 	if KILLAURA_COOLDOWN == false then 		KILLAURA_COOLDOWN = true 		if BypassedSowrd == false then 			if _G.ragebladeMobFarm == true then 				DebugCheck(0,"ragebladeMobFarm") 				local aux = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Upbolt/Hydroxide/revision/ohaux.lua"))() 				local Tool = game:GetService("Players").LocalPlayer.Character:FindFirstChild("rageblade") 				if Tool then 					local scriptPath = Tool:FindFirstChild("rageblade") -- Hier ist der error von Gestern. 					local closureName = "Unnamed function" 					local upvalueIndex = 1 					local closureConstants = { 						[1] = "isHitting", 						[2] = "getLivingEntityFromChildPart", 						[3] = "attemptHit" 					} 					local closure = aux.searchClosure(scriptPath, closureName, upvalueIndex, closureConstants) 					local value = 0 					local elementIndex = "lastClicked" 					-- DO NOT RELY ON THIS FEATURE TO PRODUCE 100% FUNCTIONAL SCRIPTS 					game:GetService("RunService").RenderStepped:Connect(function() 						debug.getupvalue(closure, upvalueIndex)[elementIndex] = value 					end) 				end 				-- Generated by Hydroxide's Upvalue Scanner: https://github.com/Upbolt/Hydroxide 				local aux = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Upbolt/Hydroxide/revision/ohaux.lua"))() 				local Tool = game:GetService("Players").LocalPlayer.Character:FindFirstChild("rageblade") 				if Tool then 					local scriptPath = Tool:FindFirstChild("rageblade") -- Hier ist der error von Gestern. 					local closureName = "Unnamed function" 					local upvalueIndex = 1 					local closureConstants = { 						[1] = "isHitting", 						[2] = "getLivingEntityFromChildPart", 						[3] = "attemptHit" 					} 					local closure = aux.searchClosure(scriptPath, closureName, upvalueIndex, closureConstants) 					local value = 4 					local elementIndex = "speed" 					debug.getupvalue(closure, upvalueIndex)[elementIndex] = value 					BypassedSowrd = true 				end 			end 		end 		if ANTICONSOLEWARNLOGANIMATION2 == false then 			ANTICONSOLEWARNLOGANIMATION2 = true 			task.spawn(function() 				for i,v in pairs(game:GetService('Players'):GetChildren()) do 					if v and v.Character and v.Character:FindFirstChild("Humanoid") then 						Player = v.Name 						AnimationId = "5328169716" 						local Anim = Instance.new("Animation") 						Anim.AnimationId = "rbxassetid://"..AnimationId 						local k = game.Players[Player].Character.Humanoid:LoadAnimation(Anim) 						k:Play() --Play the animation 						k:AdjustSpeed(0) 					end 				end 				wait(5) 				ANTICONSOLEWARNLOGANIMATION2 = false 			end) 		end	 		-- game.Players.LocalPlayer.Character:MoveTo(NM:FindFirstChild("HumanoidRootPart").Position) 		local function findNearestMob(A) 			closestPart = nil 			closestDistance = math.huge 			playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 			Table = A 			for i, part in ipairs(Table) do 				if part:FindFirstChild("HumanoidRootPart") then 					local distance = (part:FindFirstChild("HumanoidRootPart").Position - playerPosition).magnitude 					if distance < closestDistance then 						closestPart = part 						closestDistance = distance 					end 				end 			end 			return closestPart 		end 		local Mobs = workspace.WildernessIsland.Entities:GetChildren() 		SelectedMob = findNearestMob(Mobs) 		local args = { 			[1] = Hash(), 			[2] = { 				[1] = { 					[MotHitH1] = MotHitH2, 					["hitUnit"] = SelectedMob 				} 			} 		} 		game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("KillRemote").Value):FireServer(unpack(args)) 		task.wait(0.4) 		KILLAURA_COOLDOWN = false 	end end local TreeAuraCooldown = false function TreeAura() 	if TreeAuraCooldown == false then 		TreeAuraCooldown = true 		local distance = 30 		local NSEL 		if _G.SelectedTree == "all" then 			NSEL = "tree" 		else 			NSEL = _G.SelectedTree 		end 		for i,v in pairs(workspace.Islands:GetDescendants()) do 			if v.Name == "Owners" then 				if v:FindFirstChild(_G.Island_USERID) then 					for i,v in pairs(v.Parent.Blocks:GetChildren()) do 						local NekoHub_on_TOP = string.sub(v.Name:lower(), 1, string.len(NSEL)) 						if string.match(v.Name, NSEL) then 							local mag = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude 							if mag < distance then 								task.wait(0.3) 								if _G.TreeAura == true then 									local ohTable1 = { 										[HitHASHName] = HitHASH, 										["part"] = TFOUND, 										["block"] = v, 										["norm"] = Vector3.new(v.CFrame), 										["pos"] = v.Position 									} 									game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_HIT_REQUEST:InvokeServer(ohTable1) 								end 							end 						end 					end 				end 			end 		end 		task.wait(0.2) 		TreeAuraCooldown = false 	end end local voidParasiteFarmBypassCooldown2 = 0 local voidParasiteFarmBypassCooldown = 0 local voidParasiteFarmCooldown = false function voidParasiteFarm(value) 	if voidParasiteFarmCooldown == false then 		voidParasiteFarmCooldown = true 		local voidParasiteFarmTable = {} 		for i,v in pairs(game:GetService("Workspace").WildernessBlocks:GetChildren()) do 			if v.Name == "voidParasite" then 				table.insert(voidParasiteFarmTable, v) 			end 		end 		local function findNearestPart(A) 			local closestPart = nil 			local closestDistance = math.huge 			local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 			local Table = A 			for i, part in ipairs(Table) do 				local distance = (part.Position - playerPosition).magnitude 				if distance < closestDistance then 					closestPart = part 					closestDistance = distance 				end 			end 			DebugCheck(0,"findNearestPart") 			return closestPart 		end 		local TargeVoidParasite = findNearestPart(voidParasiteFarmTable) 		if not TargeVoidParasite then voidParasiteFarmCooldown = false return end 		local H1 = RemoteData:FindFirstChild("CropHashData").Value 		local H2 = _G.CropHash 		local ohTable1 = { 			[H1] = H2, 			["player"] = game:GetService("Players").LocalPlayer, 			["model"] = TargeVoidParasite 		} 		local args = { 			[1] = "sickleStone", 			[2] = { 				[1] = TargeVoidParasite 			} 		} 		voidParasiteFarmBypassCooldown = voidParasiteFarmBypassCooldown + 1 		TeleportV4(TargeVoidParasite.Position + Vector3.new(0,3,0)) 		if _G.VoidParasiteBypass == true then 			DebugCheck(0,"voidParasiteFarmBypassCooldown:"..voidParasiteFarmBypassCooldown) 			DebugCheck(0,"voidParasiteFarmBypassCooldown2:"..voidParasiteFarmBypassCooldown2) 			if voidParasiteFarmBypassCooldown < 21 then 				voidParasiteFarmBypassCooldown2 = 0 				game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.SwingSickle:InvokeServer(unpack(args)) 			else 				if voidParasiteFarmBypassCooldown2 > 21 then 					voidParasiteFarmBypassCooldown = 0 				else 					voidParasiteFarmBypassCooldown2 = voidParasiteFarmBypassCooldown2 + 1 					game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.CLIENT_HARVEST_CROP_REQUEST:InvokeServer(ohTable1) 				end 			end 		else 			if _G.VoidParasiteSichle == true then 				game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.SwingSickle:InvokeServer(unpack(args)) 			else 				game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.CLIENT_HARVEST_CROP_REQUEST:InvokeServer(ohTable1) 			end 		end		 		voidParasiteFarmCooldown = false 	end end local function spiritfindNearestPart(A) 	print("spiritfindNearestPart") 	local closestPart = nil 	local closestDistance = math.huge 	local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 	local Table = A 	for i, Model in ipairs(Table) do 		if Model:FindFirstChild("HumanoidRootPart") then 			local part = Model:FindFirstChild("HumanoidRootPart") 			if Model.Name == "spirit" then 				local distance = (part.Position - playerPosition).magnitude 				if distance < closestDistance then 					closestPart = Model 					closestDistance = distance 				end 			end 		end 	end 	print("return wäre:",closestPart) 	return closestPart end 	local spiritFarmCooldown = false 	function spiritFarm(value) 		if spiritFarmCooldown then 			return 		end 		spiritFarmCooldown = true 		if not _G.SpiritAutoFarmBool then 			return 		end 		local Entities = workspace.WildernessIsland.Entities:GetChildren() 		local KIND = spiritfindNearestPart(Entities) 		if KIND then 			if KIND.HumanoidRootPart.Position.Y <= -50 then 				KIND:Destroy() 			else 				local HttpService = game:GetService("HttpService") 				local Abd = HttpService:GenerateGUID(false) .. HttpService:GenerateGUID(false) .. HttpService:GenerateGUID(false) 				local args = { 					[1] = Abd, 					[2] = { 						[1] = { 							entity = KIND 						} 					} 				} 				local player = game.Players.LocalPlayer 				local net = game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net 				local backpack = player.Backpack:FindFirstChild("net") 				local netParent = player.Character:FindFirstChild("net") or (backpack and backpack.Parent) 				if not netParent then 					if backpack then 						backpack.Parent = player.Character 					end 					netParent = player.Character 				end 				TeleportV4(KIND.HumanoidRootPart.Position + Vector3.new(0, 1, 5)) 				pcall(function() 					net.out._NetManaged[RemoteData.SpiritRemote.Value]:FireServer(unpack(args)) 				end) 			end 		end	 		task.wait(0.25) 		spiritFarmCooldown = false 	end 	local SICHLECROPFARMCOOLDOWN = false 	local Harvesting = false 	local MAXDISCROPSICHLE = 30 	local GOTACROPTAGET = false 	local DataFromReplaceTable = loadstring(game:HttpGet(('https://raw.githubusercontent.com/pascaldercoole1/Testing-Shit/main/OBFUSECATOR-SHIT-TEST')))() 	local function SichleCropFarm(SOLLICHAUCHTELEPORTENODERNICHT) 		DebugCheck(0,"SichleCropFarm") 		if SICHLECROPFARMCOOLDOWN == false then 			SICHLECROPFARMCOOLDOWN = true 			if _G.SuperFastCropFarm == true then 				BlocksPerCall = 40 			else 				BlocksPerCall = 30 			end 			local Players = game:GetService("Players") 			local LocalPlayer = Players.LocalPlayer 			local Workspace = game:GetService("Workspace") 			local Islands = Workspace.Islands 			local ReplicatedStorage = game:GetService("ReplicatedStorage") 			local RunService = game:GetService("RunService") 			local SelectedCrop = _G.SelectedCrop 			local Island_USERID = _G.Island_USERID 			local UseSichleTool = _G.UseSichleTool 			-- Deaktivieren des experience-listener-Moduls 			-- LocalPlayer.PlayerScripts.TS.modules.experience["experience-listener"].Disabled = true 			-- Finden der Insel des Benutzers 			local function GetIsland() 				for _, Island in ipairs(Islands:GetChildren()) do 					local Owners = Island:FindFirstChild("Owners") 					if Owners and Owners:FindFirstChild(Island_USERID) then 						return Island 					end 				end 			end 			-- Finden der Blöcke, die geerntet werden sollen 			local function GetToHarvest(Island) 				local Blocks = Island:FindFirstChild("Blocks") 				local ToHarvest = {} 				if IsInTable(SelectedCrop, "all") then 					for _, Block in ipairs(Blocks:GetChildren()) do 						if Block:FindFirstChild("Targettable") then 							local MeshPart = Block:FindFirstChildWhichIsA("MeshPart") 							if MeshPart and MeshPart:FindFirstChild("Harvestable") and MeshPart.Harvestable.Value then 								local dis = (Block.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 								if dis < MAXDISCROPSICHLE then 									table.insert(ToHarvest, Block) 									GOTACROPTAGET = true 								end 							end 						end 					end 				elseif _G.SelectedCrop == {"allberrys"} then 					for _, Block in ipairs(Blocks:GetChildren()) do 						if Block and Block.Name == "berryBush" or Block.Name == "blueberryBush" or Block.Name == "blackberryBush" then 							local MeshPart = Block:FindFirstChildWhichIsA("MeshPart") 							if MeshPart and MeshPart:FindFirstChild("Harvestable") and MeshPart.Harvestable.Value then 								local dis = (Block.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 								if dis < MAXDISCROPSICHLE then 									table.insert(ToHarvest, Block) 									GOTACROPTAGET = true 								end 							end 						end 					end 				else 					for _, Block in ipairs(Blocks:GetChildren()) do 						if IsInTable(SelectedCrop, Block.Name) then 							local MeshPart = Block:FindFirstChildWhichIsA("MeshPart") 							if MeshPart and MeshPart:FindFirstChild("Harvestable") and MeshPart.Harvestable.Value then 								local dis = (Block.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 								if dis < MAXDISCROPSICHLE then 									table.insert(ToHarvest, Block) 									GOTACROPTAGET = true 								end 							end 						end 					end 				end 				return ToHarvest 			end 			-- Finden der Blöcke, die geerntet werden sollen 			local function GetToHarvestTP(Island) 				local Blocks = Island:FindFirstChild("Blocks") 				local ToHarvesttp = {} 				if IsInTable(SelectedCrop, "all") then 					for _, Block in ipairs(Blocks:GetChildren()) do 						if Block:FindFirstChild("Targettable") then 							local MeshPart = Block:FindFirstChildWhichIsA("MeshPart") 							if MeshPart and MeshPart:FindFirstChild("Harvestable") and MeshPart.Harvestable.Value then 								local dis = (Block.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 								--if dis < MAXDISCROPSICHLE then 								table.insert(ToHarvesttp, Block) 								DebugCheck(0,"GetToHarvestTP") 								--end 							end 						end 					end 				elseif _G.SelectedCrop == {"allberrys"} then 					for _, Block in ipairs(Blocks:GetChildren()) do 						if Block.Name == "berryBush" or Block.Name == "blueberryBush" or Block.Name == "blackberryBush" then 							local MeshPart = Block:FindFirstChildWhichIsA("MeshPart") 							if MeshPart and MeshPart:FindFirstChild("Harvestable") and MeshPart.Harvestable.Value then 								local dis = (Block.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 								--if dis < MAXDISCROPSICHLE then 								table.insert(ToHarvesttp, Block) 								--end 							end 						end 					end 				else 					print("OTHER") 					for _, Block in ipairs(Blocks:GetChildren()) do 						if IsInTable(SelectedCrop, Block.Name) then 							local MeshPart = Block:FindFirstChildWhichIsA("MeshPart") 							if MeshPart and MeshPart:FindFirstChild("Harvestable") and MeshPart.Harvestable.Value then 								local dis = (Block.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 								--if dis < MAXDISCROPSICHLE then 								table.insert(ToHarvesttp, Block) 								DebugCheck(0,"GetToHarvestTP") 								--end 							end 						end 					end 				end 				return ToHarvesttp 			end 			task.wait() 			-- Funktion zum Finden des nächsten Teils 			local function findNearestPart(A) 				local closestPart = nil 				local closestDistance = math.huge 				local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 				local Table = A 				for i, part in ipairs(Table) do 					local distance = (part.Position - playerPosition).magnitude 					if distance < closestDistance then 						closestPart = part 						closestDistance = distance 					end 				end 				DebugCheck(0,"findNearestPart") 				return closestPart 			end 			local function Ernte() 				DebugCheck(0,"Ernte") 				-- Ernte 				local ToHarvest = GetToHarvest(GetIsland()) 				local ToHarvestLength = #ToHarvest 				local BlocksPerCall = 50 				local Count = 1 				BlocksPerCall = 150 				if _G.SuperFastCropFarm == true then 					BlocksPerCall = 300 				end 				if ToHarvest == nil or ToHarvest == {} then 					DebugCheck(0,"NICHTS GEFUNDEN!!!") 					return 0; 				end 			--[[ 			 			if GOTACROPTAGET == false then 				task.wait() 				SICHLECROPFARMCOOLDOWN = false 				SichleAuraCooldown = false 				return nil 			end 			if ToHarvest == nil then 				SICHLECROPFARMCOOLDOWN = false 				SichleAuraCooldown = false 				return nil 			end 			]] 				-- Speichern der ursprünglichen Positionen der geernteten Blöcke 				local OriginalPositions = {} 				local OriginalNames = {} 				_G.OriginalNames = {} 				_G.OriginalPositions = {} 				for i, Block in ipairs(ToHarvest) do 					OriginalPositions[i] = Block.CFrame 					OriginalNames[i] = Block.Name 					_G.OriginalPositions[i] = Block.CFrame 					_G.OriginalNames[i] = Block.Name 				end 				DebugCheck(0,"while gay") 				local Args = {} 				DebugCheck(0,"Start While ") 				while Count <= ToHarvestLength do 					task.wait() 					local HarvestCount = math.min(ToHarvestLength - Count + 1, BlocksPerCall) 					for i = Count, Count + HarvestCount - 1 do 						Args[i - Count + 1] = ToHarvest[i] 					end 					Count = Count + HarvestCount 				end 				DebugCheck(0,"Finish While") 				task.wait(0.1) 				ReplicatedStorage.rbxts_include.node_modules["@rbxts"].net.out._NetManaged.SwingSickle:InvokeServer(UseSichleTool, Args) 				local A = 0 				local AACOUNT = 1 				local Placeing = true 				-- Zurücksetzen der Blöcke an den ursprünglichen CFrame 				local ISTTTTON = true 				-- task.wait(0.6) 				if _G.AutoReplaceCrop == true then 					local TTTT = game:GetService("RunService").RenderStepped:Connect(function() 						if A < 40 then 							task.wait() 							A = A + 1 							for Blocki = 1, #ToHarvest do 								if ISTTTTON == false then return nil end 								if OriginalPositions[AACOUNT] and OriginalPositions[AACOUNT] ~= nil and OriginalPositions[AACOUNT] ~= nil then 									_G.orgPos = OriginalPositions[AACOUNT] 									_G.AACOUNT = AACOUNT 									-- __IGNORESTR__ 									-- loadstring("__IGNORESTR__local ohTable1 = {['upperBlock'] = false,[_G.CropPlaceH1] = _G.CropPlaceHash,['cframe'] = _G.orgPos,['blockType'] = _G.OriginalNames[_G.AACOUNT]};game:GetService('ReplicatedStorage').rbxts_include.node_modules['@rbxts'].net.out._NetManaged.CLIENT_BLOCK_PLACE_REQUEST:InvokeServer(ohTable1)")() 									loadstring("local ohTable1 = {['upperBlock'] = false,[_G.CropPlaceH1] = _G.CropPlaceHash,['cframe'] = _G.orgPos,['blockType'] = _G.OriginalNames[_G.AACOUNT]};game:GetService('ReplicatedStorage').rbxts_include.node_modules['@rbxts'].net.out._NetManaged.CLIENT_BLOCK_PLACE_REQUEST:InvokeServer(ohTable1)")() 									AACOUNT = AACOUNT + 1 								else 									AACOUNT = AACOUNT + 1 									-- warn("Original position of block " .. Block.Name .. " is nil. Skipping reset.") 								end 							end 							Placeing = false 						end 					end) 				end 			end 			if _G.SuperFastCropFarm ~= true then 				task.wait(0.4) 			end 			if _G.SuperFastCropFarm ~= true then 				if _G.SafeUseSichle == true then 					task.wait(1.5) 				end 			end 			local IsThere = false 			-- Teleportieren zur ausgewählten Ernte 			if SOLLICHAUCHTELEPORTENODERNICHT == true then 				DebugCheck(0,"SOLLICHAUCHTELEPORTENODERNICHT is true") 				local ToHarvest = GetToHarvestTP(GetIsland()) 				task.wait(0.2) 				local PPPPPOSSS = findNearestPart(ToHarvest) 				if PPPPPOSSS then 					TeleportV4(PPPPPOSSS.Position) 					DebugCheck(0,"Tween Fertig!!!!") 					Completed = true 					Ernte() 					Harvesting = false 					SICHLECROPFARMCOOLDOWN = false 					SichleAuraCooldown = false 					SichleFarmCooldown = false 				else 					Completed = true 					Harvesting = false 					SICHLECROPFARMCOOLDOWN = false 					SichleAuraCooldown = false 					SichleFarmCooldown = false 				end 						--[[ 						 			local Island = GetIsland() 			for i, Block in ipairs(Island:FindFirstChild("Blocks"):GetChildren()) do 				if IsThere == true then return nil end 				if Block.Name == SelectedCrop then 				local MeshPart = Block:FindFirstChildWhichIsA("MeshPart") 				if MeshPart and MeshPart:FindFirstChild("Harvestable") and MeshPart.Harvestable.Value == true then 					local dis = (Block.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude 					if dis < MAXDISCROPSICHLE then 						IsThere = true 						 					end 				end 				end 			end 						]] 			else 				Ernte() 				Harvesting = false 				SICHLECROPFARMCOOLDOWN = false 				SichleAuraCooldown = false 				SichleFarmCooldown = false 			end 			if TTTT then 				TTTT:Disconnect() 			end 			ISTTTTON = false 			SICHLECROPFARMCOOLDOWN = false 			SichleFarmCooldown = false	 		end 	end 	local PLAC222 = false 	function SeedAura(V) 		if PLAC222 == false then 			PLAC222 = true 			local Island = GetIsland() 			local center = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 			local radius = _G.PlowDistance or 5 			local region = Region3.new(center - Vector3.new(radius, radius, radius), center + Vector3.new(radius, radius, radius)) 			local Blocks = workspace:FindPartsInRegion3(region, nil, math.huge) 			local ANTILAG_BOSS_Crown_Crepper_Is_Gay = 0 			task.wait(0.1) 			local ToLace = "wheat" 			for i = 1,#Blocks do 				local v = Blocks[i] 				if v.Parent == Island:FindFirstChild("Blocks") then 					if v.Name == "soil" then 						task.wait() 						task.spawn(function() 							local Tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") 							if Tool then 								if Tool:FindFirstChild("seeds") then 									function removeSeeds(itemName) 										local index = string.find(itemName, "Seeds") 										if index ~= nil then 											return string.sub(itemName, 1, index - 1) 										else 											return itemName 										end 									end 									ToLace = removeSeeds(Tool.Name) 								else 									task.wait(0.1) 									PLAC222 = false 									return nil 								end 							end 							task.wait() 							local ohTable1 = { 								["upperBlock"] = false, 								["cframe"] = CFrame.new(v.Position + Vector3.new(0,3,0)), 								["blockType"] = ToLace or "wheat", 								[PlaceHASHName] = PlaceHASH 							} 							game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_PLACE_REQUEST:InvokeServer(ohTable1) 						end) 					end 				end 			end 			task.wait(0.1) 			PLAC222 = false 		end 	end 	-- HHAHAHAHGZQ(AG) 	local PET_ANIMALFarmCoolDowm = false 	function PET_ANIMALFarm(V) 		if PET_ANIMALFarmCoolDowm == false then 			PET_ANIMALFarmCoolDowm = true 			local Island = GetIsland() 			local Entities = Island:FindFirstChild("Entities") 			if Entities then 				Entities = Island:FindFirstChild("Entities"):GetChildren() 				for i = 1,#Entities do 					if Entities[i].Name == "cow" or Entities[i].Name == "pig" or Entities[i].Name == "sheep" or Entities[i].Name == "chicken" then 						if V == true then 							TeleportV4(Entities[i]:FindFirstChild("HumanoidRootPart").Position) 						else 							local args = { 								[1] = { 									["animal"] = Entities[i] 								}} 							game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("PetCollect").Value):InvokeServer(unpack(args)) 						end 						wait() 						local args = { 							[1] = { 								["animal"] = Entities[i] 							}} 						for i = 1,1 do 							game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("PetCollect").Value):InvokeServer(unpack(args)) 							if Entities[i]:FindFirstChild("oldName") == nil then 								local OLD = Instance.new("StringValue") 								OLD.Name = "oldName" 								OLD.Parent = Entities[i] 								OLD.Value = Entities[i].Name 								Entities[i] = "GG" 							end 							Entities[i] = "GG" 						end 					end 					Entities = Island:FindFirstChild("Entities"):GetChildren() 					for i = 1,#Entities do 						if Entities[i]:FindFirstChild("oldName") then 							Entities[i].Name = Entities[i]:FindFirstChild("oldName").Value 						end 					end 				end 			end 			PET_ANIMALFarmCoolDowm = false 		end 	end 	AutoPickUpCooldown = false 	function AutoPickupItems() 		if AutoPickUpCooldown == true then return nil end 		AutoPickUpCooldown = true 		local Island = GetIsland() 		local Tools = Island:FindFirstChild("Drops"):GetChildren() 		local PublicTools = game:GetService("Workspace"):FindFirstChild("game:WildernessDrops"):FindFirstChild("WildDropsFolder"):GetChildren() 		for i = 1,#Tools do 			local ohTable1 = { 				["tool"] = Tools[i], 				[PickupH1] = PickupH2 			} 			game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_TOOL_PICKUP_REQUEST:InvokeServer(ohTable1) 		end 		for i = 1,#PublicTools do 			local ohTable1 = { 				["tool"] = PublicTools[i], 				[PickupH1] = PickupH2 			} 			game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_TOOL_PICKUP_REQUEST:InvokeServer(ohTable1) 		end 		AutoPickUpCooldown = false 	end 	local CIsland = false 	function CleanIsland() 		if CIsland == false then 			CIsland = true 			local Island = GetIsland() 			local Blocks = Island:FindFirstChild("Blocks") 			local Targets = {} 			local Targetnames = {"tallGrass", "naturalRock1"} 			for i,v in pairs(Blocks:GetChildren()) do 				for y,c in pairs(Targetnames) do 					if c == v.Name then 						table.insert(Targets, v) 						DebugCheck(0,"ADDED!",c) 					end 				end 			end 			local function findNearestPart(A) 				local closestPart = nil 				local closestDistance = math.huge 				local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 				local Table = A 				for i, part in ipairs(Table) do 					local distance = (part.Position - playerPosition).magnitude 					if distance < closestDistance then 						closestPart = part 						closestDistance = distance 					end 				end 				DebugCheck(0,"findNearestPart") 				return closestPart 			end 			local closestPart = findNearestPart(Targets) 			if closestPart then 				TeleportV4(closestPart.Position) 				task.wait() 				if closestPart then 					local GPART = closestPart:FindFirstChildWhichIsA("Part") or closestPart:FindFirstChildWhichIsA("MeshPart") 					local args = { 						[1] = { 							[HitHASHName] = HitHASH, 							["part"] = GPART, 							["block"] = closestPart, 							["norm"] = closestPart.Position, 							["pos"] = GPART.Position 						} 					} 					if closestPart then 						local dis = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - closestPart.Position).Magnitude 						if dis < 30 then 							for i = 1,3 do 								if closestPart then 									game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild(RemoteData:FindFirstChild("BlockRemote").Value):InvokeServer(unpack(args)) 									task.wait() 								end 							end 							task.wait(0.5) 							CIsland = false 						else 							task.wait(0.5) 							CIsland = false 						end 					else 						task.wait(0.5) 						CIsland = falsec 					end 				end 			else 				task.wait(0.5) 				CIsland = false 			end 		end 	end 	local FFC = false 	function flowerFarm(V) 		if FFC == false then 			FFC = true 			local Island = GetIsland() 			local Blocks = Island:FindFirstChild("Blocks"):GetChildren() 			if Island:FindFirstChild("Blocks") then 				for i,v in pairs(Blocks) do 					if v:FindFirstChild("flower") then 						if V == true then 							TeleportV4(v.Position) 							task.wait(0.5) 						end 						local args = { 							[1] = { 								["flower"] = v 							} 						} 						game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.client_request_1:InvokeServer(unpack(args)) 					end 				end 			end 			task.wait(2) 			FFC = false 		end 	end 	local PLAC = false 	function PlowAura(V) 		if PLAC == false then 			PLAC = true 			local Island = GetIsland() 			local center = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 			local radius = _G.PlowDistance or 30 			local region = Region3.new(center - Vector3.new(radius, radius, radius), center + Vector3.new(radius, radius, radius)) 			local Blocks = workspace:FindPartsInRegion3(region, nil, math.huge) 			local LMAO 			if V == true then 				LMAO = "grass" 			else 				LMAO = "soil" 			end 			local CVS = 0 			local A = 0 			for i = 1,#Blocks do 				task.spawn(function() 					local v = Blocks[i] 					if v.Parent == Island:FindFirstChild("Blocks") then 						if v.Name == LMAO then 							local ohTable1 = { 								["block"] = v 							} 							if LMAO == "grass" then 								if _G.PlowAura == true then 									game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_PLOW_BLOCK_REQUEST:InvokeServer(ohTable1) 								end 							elseif LMAO == "soil" then 								if _G.UnPlowAura == true then 									game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_PLOW_BLOCK_REQUEST:InvokeServer(ohTable1) 								end 							end 						end 					end 				end) 			end 		end 		task.wait(0.1) -- Drecks obfuser 		PLAC = false 	end 	local Human = game.Players.LocalPlayer.Character:WaitForChild("Humanoid") 	Human:GetPropertyChangedSignal("WalkSpeed"):Connect(function() 		Human.WalkSpeed = _G.WalkSpeed or 30 	end) 	-- // functions \\ -- 	local __CHECKVIP__ = game:GetService("Workspace"):WaitForChild("PrivateServer") 	if __CHECKVIP__ then 		if __CHECKVIP__.Value == false then 			Message("WARNING!", "THE SCRIPT IS SAFE ON VIP SERVERS! PUBLIC SERVERS ARE UNSAFE MODS CAN BAN YOU!", "Okay!") 		end 	end 	local OP = false 	function OpenPresent() 		if OP == false then 			OP = true 			local args = { 				[1] = {} 			} 			game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.client_request_22:InvokeServer(unpack(args)) 			task.wait(0.1) 			OP = false 		end 	end 	local GIftCO = false 	function GiftFarm() 		if GIftCO == false then 			GIftCO = true 			local distance = 10000 			for i,v in pairs(workspace.Islands:GetDescendants()) do 				if v.Name == "Owners" then 					if v:FindFirstChild(_G.Island_USERID) then 						for i,v in pairs(v.Parent.Blocks:GetChildren()) do 							local NekoHub_on_TOP = string.sub(v.Name:lower(), 1, string.len("christmas")) 							if (NekoHub_on_TOP == "christmas") then 								local mag = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Position).Magnitude 								if mag < distance then 									local ohTable1 = {["player_tracking_category"] = "join_from_web",["part"] = v:WaitForChild("Present"),["block"] = v,["norm"] = Vector3.new(v.CFrame),["pos"] = v.Position} 									if _G.Event_Presents_Farm == true then 										if _G.TeleportMethod == "Tween" then 											if v then 												TweenTp(v.Position + Vector3.new(0,1,0)) 											end 										elseif _G.TeleportMethod == "Instant" then 											if v then 												game.Players.LocalPlayer.Character:MoveTo(v.Position + Vector3.new(0,1,0)) 											end 										elseif _G.TeleportMethod == "Pathfinding" then 											if v then 												PathFindingSystem(v) 											end 										end 										while v and v ~= nil do 											task.wait() 											if v ~= nil then 												game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_HIT_REQUEST:InvokeServer(ohTable1) 												if _G.TeleportMethod == "Tween" then 													if v ~= nil then 														TweenTp(v.Position + Vector3.new(0,1,0)) 													else 														GIftCO = false 													end 												elseif _G.TeleportMethod == "Instant" then 													if v ~= nil then 														game.Players.LocalPlayer.Character:MoveTo(v.Position + Vector3.new(0,1,0)) 													else 														GIftCO = false 													end 												elseif _G.TeleportMethod == "Pathfinding" then 													if v ~= nil then 														PathFindingSystem(v) 													else 														GIftCO = false 													end 												end 												game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].net.out._NetManaged.CLIENT_BLOCK_HIT_REQUEST:InvokeServer(ohTable1) 											else 												DebugCheck(0,"OFF") 												GIftCO = false 											end 										end 										DebugCheck(0,"OFF") 										GIftCO = false 									end 								end 							end 						end 					end 				end 			end 			task.wait(5) 			GIftCO = false 		end 	end 	function CheckDouble(Option) 		if Option == "Skorpions" then 			_G.SelectedMobs = {"skorpRuby","skorpGold","skorpIron", "skorpSerpent"} 			_G.CheckDoubleIsTrue = true 			return {"skorpRuby","skorpGold","skorpIron", "skorpSerpent"} 		elseif type(Option) == "table" then 			for i,v in pairs(Option) do 				if v == "Skorpions" then 					local END = Option 					table.insert(END, "skorpRuby") 					table.insert(END, "skorpGold") 					table.insert(END, "skorpIron") 					table.insert(END, "skorpSerpent") 					return END 				end 			end 		else 			DebugCheck(0,"CheckDouble: false") 			return Option 		end 	end 	function GetPlayerInfos(PlayerName) 		if game:GetService("Players"):FindFirstChild(PlayerName) then 			local Player = game:GetService("Players"):FindFirstChild(PlayerName) 			local UserId = Player.UserId 			local AccountAge = game.P